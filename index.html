<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encontre Nossos Representantes</title>

    <!-- Dependências do Mapa (Leaflet.js) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Estilização com Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <style>
        /* Remover todos os outlines de focus */
        * {
            outline: none !important;
        }

        /* Remover focus específico de botões e inputs */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        body,
        html {
            height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            overflow-x: hidden;
        }

        #representantes-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .grid-container {
            flex: 1;
            display: grid;
            gap: 1rem;
            grid-template-columns: 1fr;
            min-height: 0;
        }

        @media (min-width: 1024px) {
            .grid-container {
                grid-template-columns: 3fr 2fr;
                gap: 2rem;
            }
        }

        .map-container {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .map-wrapper {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            padding: 1rem;
            position: relative;
            min-height: 300px;
        }

        #map {
            height: 100%;
            width: 100%;
            border-radius: 0.5rem;
            background-color: #fff;
            min-height: 300px;
        }

        @media (min-width: 768px) {
            #map {
                min-height: 400px;
            }
        }

        @media (min-width: 1024px) {
            #map {
                min-height: calc(100vh - 200px);
            }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .sidebar-content {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
            max-height: 400px;
        }

        @media (min-width: 1024px) {
            .results-container {
                max-height: calc(100vh - 300px);
            }
        }

        @media (max-height: 600px) {
            .results-container {
                max-height: 250px;
            }

            #map {
                min-height: 250px;
            }
        }

        /* Melhorias para dispositivos móveis muito pequenos */
        @media (max-width: 480px) {
            #representantes-container {
                padding: 0.5rem;
            }

            .main-content {
                gap: 0.5rem;
            }

            .map-wrapper {
                padding: 0.5rem;
            }

            .sidebar-content {
                padding: 1rem;
            }

            .results-container {
                max-height: 300px;
            }
        }

        @media (max-width: 480px) and (max-height: 700px) {
            #map {
                min-height: 200px;
            }

            .results-container {
                max-height: 200px;
            }
        }

        /* Ajustes para orientação landscape em dispositivos móveis */
        @media (max-height: 500px) and (orientation: landscape) {
            .grid-container {
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }

            #map {
                min-height: 200px;
            }

            .results-container {
                max-height: 200px;
            }

            #representantes-container {
                padding: 0.5rem;
            }
        }

        .leaflet-interactive {
            transition: fill-opacity 0.2s ease-in-out;
        }

        .result-item {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* .municipio-tooltip {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
        } */

        /* Botão de Reset Zoom */
        .reset-zoom-btn {
            position: absolute;
            bottom: 10px;
            right: 50px;
            z-index: 1000;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reset-zoom-btn:hover {
            background: #f4f4f4;
            border-color: rgba(0, 0, 0, 0.4);
        }

        .reset-zoom-btn svg {
            width: 18px;
            height: 18px;
            color: #333;
        }

        /* Botão de Maximizar Mapa */
        .maximize-map-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .maximize-map-btn:hover {
            background: #f4f4f4;
            border-color: rgba(0, 0, 0, 0.4);
        }

        .maximize-map-btn svg {
            width: 18px;
            height: 18px;
            color: #333;
        }

        /* Estado maximizado */
        .map-maximized .grid-container {
            grid-template-columns: 1fr !important;
        }

        .map-maximized .sidebar {
            display: none !important;
        }

        .map-maximized .map-container {
            grid-column: 1 / -1;
        }

        .map-maximized .map-wrapper {
            min-height: calc(100vh - 100px) !important;
        }

        /* Modo tela cheia real */
        .map-fullscreen {
            overflow: hidden !important;
        }

        .map-fullscreen #representantes-container {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            background: white !important;
            padding: 0 !important;
            margin: 0 !important;
            max-width: none !important;
        }

        .map-fullscreen .map-wrapper {
            height: 100vh !important;
            min-height: 100vh !important;
            border-radius: 0 !important;
            padding: 0 !important;
        }

        .map-fullscreen #map {
            height: 100vh !important;
            min-height: 100vh !important;
            border-radius: 0 !important;
        }

        .map-fullscreen .maximize-map-btn {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 10000 !important;
        }

        /* Labels dos municípios - Fixos e sempre visíveis */
        /* CSS das labels comentado pois as labels foram removidas
        .municipio-label-fixo {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            font-size: 5px !important;
            font-weight: 600 !important;
            color: #333 !important;
            text-align: center !important;
            white-space: nowrap !important;
            box-shadow: none !important;
            pointer-events: none !important;
            z-index: 1000 !important;
            font-family: 'Inter', sans-serif !important;
            line-height: 1.2 !important;
            max-width: 120px !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            text-shadow: 
                -1px -1px 0 #ffffff,
                1px -1px 0 #ffffff,
                -1px 1px 0 #ffffff,
                1px 1px 0 #ffffff;
        }
        
        .municipio-label-container {
            background: transparent !important;
            border: none !important;
        }

        /* Ajustar tamanho do texto baseado no zoom */
        .leaflet-zoom-animated .municipio-label-fixo {
            font-size: 7px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-6 .municipio-label-fixo,
        .leaflet-zoom-animated.leaflet-zoom-level-7 .municipio-label-fixo {
            font-size: 8px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-8 .municipio-label-fixo,
        .leaflet-zoom-animated.leaflet-zoom-level-9 .municipio-label-fixo {
            font-size: 9px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-10 .municipio-label-fixo {
            font-size: 10px !important;
        }

        */

        /* Estilos para busca melhorada */
        .search-filter.active {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: #ffffff;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4), 0 2px 4px rgba(37, 99, 235, 0.3);
            font-weight: 500;
        }

        .search-filter.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: inherit;
            pointer-events: none;
        }

        .search-filter.active i,
        .search-filter.active span {
            position: relative;
            z-index: 1;
            color: #ffffff !important;
        }

        .search-filter {
            background-color: #f8fafc;
            color: #64748b;
            border-color: #e2e8f0;
            font-weight: 400;
        }

        .search-filter:hover:not(.active) {
            background-color: #f1f5f9;
            border-color: #cbd5e1;
            color: #475569;
        }

        .search-filter:hover:not(.active) i {
            color: #475569 !important;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .suggestion-item:hover, .suggestion-item.highlighted {
            background-color: #f3f4f6;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-type {
            font-size: 10px;
            background-color: #e5e7eb;
            color: #6b7280;
            padding: 2px 6px;
            border-radius: 10px;
            text-transform: uppercase;
            font-weight: 500;
            margin-left: 8px;
        }

        .recent-search-item {
            background-color: #f3f4f6;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recent-search-item:hover {
            background-color: #e5e7eb;
            color: #374151;
        }

        #clear-search {
            transition: all 0.2s;
        }

        /* Animações e transições melhoradas */
        #suggestions-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease-out;
        }

        #suggestions-container:not(.hidden) {
            opacity: 1;
            transform: translateY(0);
        }

        .search-filter {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: scale(1);
            position: relative;
            overflow: hidden;
        }

        .search-filter:hover {
            transform: scale(1.02) translateY(-1px);
        }

        .search-filter.active {
            transform: scale(1.02) translateY(-1px);
        }

        .search-filter:active {
            transform: scale(0.98) translateY(0px);
        }

        .recent-search-item {
            transition: all 0.2s ease-out;
            transform: scale(1);
        }

        .recent-search-item:hover {
            transform: scale(1.05);
        }

        /* Indicador de loading no input */
        .search-loading::after {
            content: '';
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border: 2px solid #f3f4f6;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }

        /* Estados do input */
        #search-input:focus {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        #search-input.has-results {
            border-color: #10b981;
        }

        #search-input.no-results {
            border-color: #ef4444;
        }

        #search-input.has-suggestions {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        #search-input.has-suggestions::placeholder {
            color: #3b82f6;
            opacity: 0.7;
        }

        /* Estilos para telefones nos cards */
        .phone-pill {
            display: inline-flex;
            align-items: center;
            background-color: #eff6ff;
            color: #2563eb;
            padding: 4px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            text-decoration: none;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .phone-pill:hover {
            background-color: #dbeafe;
            border-color: #93c5fd;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
        }

        .phone-expand-btn {
            background-color: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
            transition: all 0.2s ease;
        }

        .phone-expand-btn:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        /* Estilos para bairros de São Paulo */
        .bairro-with-rep {
            /* filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.8)) 
                    drop-shadow(0 0 6px rgba(255, 255, 255, 0.6)); */
        }

        .bairro-without-rep {
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.7)) 
                    drop-shadow(0 0 4px rgba(255, 255, 255, 0.5));
        }

        /* Alternativa usando outline para SVG paths */
        .leaflet-interactive.bairro-with-rep {
            stroke-dasharray: 1,10 !important;
            stroke: #ffffff !important;
            stroke-width: 3px !important;
            /* filter: drop-shadow(0 0 10px white); */
        }

        .leaflet-interactive.bairro-without-rep {
            stroke-dasharray: 6,4 !important;
            stroke: #DC2626 !important;
            stroke-width: 2 !important;
            opacity: 0.6 !important;
            filter: drop-shadow(0 0 2px white);
        }
    </style>

</head>

<body class="bg-gray-50">

    <div id="representantes-container" class="container mx-auto p-2 sm:p-4 lg:p-6 max-w-7xl">

        <div class="mb-4 lg:mb-6">
            <h1 id="main-title" class="text-xl sm:text-2xl lg:text-3xl font-bold text-gray-800">Escolha sua região para
                encontrar
                representantes</h1>
            <button id="back-to-brazil" class="hidden text-blue-600 font-semibold mt-2 hover:underline">&lt; VOLTAR PARA
                O MAPA DO BRASIL</button>
        </div>

        <div class="main-content">
            <div class="grid-container">

                <!-- Coluna do Mapa -->
                <div class="map-container">
                    <div class="map-wrapper">
                        <div id="map"></div>
                        <button id="reset-zoom-btn" class="reset-zoom-btn" title="Resetar zoom">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" />
                            </svg>
                        </button>

                        <button id="maximize-map-btn" class="maximize-map-btn" title="Maximizar mapa">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Coluna de Busca e Resultados -->
                <div class="sidebar">
                    <div class="sidebar-content">
                        <h2 class="text-lg sm:text-xl font-bold text-gray-800 mb-4">SEUS REPRESENTANTES</h2>

                        <div class="mb-4 relative">
                            <!-- Campo de busca principal -->
                            <div class="relative">
                                <input type="text" id="search-input" placeholder="Ex: São Paulo, SCHIOPPA em SP, Santos..."
                                    class="w-full px-10 py-2 sm:px-12 sm:py-3 border border-gray-300 rounded-lg outline-none transition text-sm sm:text-base focus:border-blue-500 focus:ring-2 focus:ring-blue-200"
                                    autocomplete="off">
                                <!-- Ícone de busca -->
                                <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400"></i>
                                
                                <!-- Botão para limpar busca -->
                                <button id="clear-search" class="absolute right-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 hover:text-gray-600 hidden">
                                    <i data-lucide="x" class="h-4 w-4"></i>
                                </button>
                            </div>
                            
                            <!-- Dropdown de sugestões -->
                            <div id="suggestions-container" class="absolute top-full left-0 right-0 z-50 bg-white border border-gray-200 rounded-lg shadow-lg mt-1 max-h-64 overflow-y-auto hidden">
                                <div id="suggestions-list"></div>
                            </div>
                            
                            <!-- Filtros rápidos -->
                            <div class="flex flex-wrap gap-2 mt-3">
                                <button class="search-filter active px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="all">
                                    <i data-lucide="globe" class="h-3 w-3"></i>
                                    Todos
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="estados">
                                    <i data-lucide="map" class="h-3 w-3"></i>
                                    Estados
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="cidades">
                                    <i data-lucide="map-pin" class="h-3 w-3"></i>
                                    Cidades
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="bairros">
                                    <i data-lucide="home" class="h-3 w-3"></i>
                                    Bairros (SP)
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="representantes">
                                    <i data-lucide="users" class="h-3 w-3"></i>
                                    Representantes
                                </button>
                            </div>
                            
                            <!-- Histórico de buscas recentes -->
                            <div id="recent-searches" class="mt-3 hidden">
                                <h4 class="text-xs font-medium text-gray-600 mb-2 flex items-center gap-1">
                                    <i data-lucide="clock" class="h-3 w-3"></i>
                                    Buscas recentes:
                                </h4>
                                <div id="recent-searches-list" class="flex flex-wrap gap-1"></div>
                            </div>
                        </div>

                        <div id="results-container" class="results-container space-y-3 pr-2">
                            <div id="initial-message" class="text-center py-16">
                                <div id="loading-indicator">
                                    <svg class="animate-spin mx-auto h-12 w-12 text-blue-600"
                                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                            stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor"
                                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                        </path>
                                    </svg>
                                    <p class="mt-4 text-sm text-gray-500">Carregando dados...</p>
                                </div>
                                <div id="default-message" class="hidden">
                                    <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg"
                                        fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round"
                                            d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m5.231 13.481L15 17.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Zm3.75 11.625a2.625 2.625 0 1 1-5.25 0 2.625 2.625 0 0 1 5.25 0Z" />
                                    </svg>
                                    <p class="mt-4 text-sm text-gray-500">Use a busca ou clique em um estado no mapa.
                                    </p>
                                </div>
                            </div>

                            <!-- Legenda de Representantes -->
                            <div id="legend" class="legend hidden mt-4 p-3 bg-white rounded-lg border border-gray-200">
                                <h3 class="text-sm font-semibold text-gray-700 mb-2">Legenda de Cores</h3>
                                <div id="legend-items" class="space-y-1 max-h-32 overflow-y-auto"></div>
                                <div class="mt-2 pt-2 border-t border-gray-200">
                                    <div class="flex items-center text-xs text-gray-600">
                                        <div class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                                        <span>Sem representante</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            document.addEventListener('DOMContentLoaded', async function () {
                // --- CONFIGURAÇÃO ---
                const jsonFileUrl = './data/representantes_por_estado.json';
                const municipiosJsonUrl = 'https://raw.githubusercontent.com/screamonei2/mapa-brasil-representantes/main/old/geojs-100-mun-v2.json';

                // URL do GeoJSON dos estados do Brasil
                const brazilStatesGeoJsonUrl = './data/uf.json';

                // URL do GeoJSON dos bairros de São Paulo
                const bairrosGeoJsonUrl = './data/bairros.geojson';

                // --- VARIÁVEIS GLOBAIS ---
                let representativesData = [];
                let representativesByLocation = new Map();
                let municipiosData = [];
                let map;
                let geoJsonLayer;
                let municipiosLayer = null;
                let bairrosLayer = null;
                let selectedStateLayer = null;
                let selectedMunicipioLayer = null;
                let currentState = null;
                let viewMode = 'states'; // 'states' ou 'municipios'
                let municipioRepresentativeMap = new Map(); // Mapa município -> representantes
                let representativeColorMap = new Map(); // Mapa representante -> cor
                let highlightedMunicipiosLayer = null; // Camada para destacar municípios do representante

                // Paleta de cores para representantes (azul padrão como primeira cor para SCHIOPPA)
                const representativeColors = ['#206ce7', '#3c27f5', '#a831ff', '#ed57e4', '#f762a6', '#ff0e09', '#e98e32', '#f6f23a', '#aaff46', '#72ef6a', '#13f472', '#1dffe8', '#45aceb', '#4e66f6', '#925aff', '#c420e7', '#f527b7', '#ff315f', '#ed7e57', '#f7d062', '#c8ff09', '#69e932', '#3af65c', '#46ffc0', '#6adcef', '#1369f4', '#341dff', '#a545eb', '#f64eec', '#ff5aa6', '#e72420', '#f58e27', '#fffa31', '#a8ed57', '#6af762', '#09ff70', '#32e9d7', '#3aaef6', '#4660ff', '#976aef', '#cb13f4', '#ff1dbb', '#eb4569', '#f67a4e', '#ffd45a', '#bbe720', '#65f527']
                    ;

                // Mapa específico de cores para representantes especiais
                // COMENTADO: Não é mais necessário, cores estão em representativeColors
                // const specialRepresentativeColors = {
                //     'schioppa': '#3b82f6',  // Azul padrão para SCHIOPPA
                //     'rg representacoes ltda': '#dc2626',  // Vermelho para RG REPRESENTAÇÕES (código 42)
                //     '3l representacoes comerciais ltda me': '#FF0000'  // Vermelho para 3L REPRESENTAÇÕES
                // };

                const searchInput = document.getElementById('search-input');
                const resultsContainer = document.getElementById('results-container');
                const initialMessage = document.getElementById('initial-message');
                const loadingIndicator = document.getElementById('loading-indicator');
                const defaultMessage = document.getElementById('default-message');
                const backButton = document.getElementById('back-to-brazil');
                const mainTitle = document.getElementById('main-title');
                
                // Novos elementos para busca melhorada
                const clearSearchButton = document.getElementById('clear-search');
                const suggestionsContainer = document.getElementById('suggestions-container');
                const suggestionsList = document.getElementById('suggestions-list');
                const recentSearches = document.getElementById('recent-searches');
                const recentSearchesList = document.getElementById('recent-searches-list');
                const searchFilters = document.querySelectorAll('.search-filter');
                
                // Variáveis para controle da busca
                let currentSearchFilter = 'all';
                let searchSuggestions = [];
                let selectedSuggestionIndex = -1;
                let recentSearchesData = JSON.parse(localStorage.getItem('recentSearches') || '[]');

                // --- FUNÇÕES DE TRANSFORMAÇÃO DE DADOS ---

                function transformRepresentativesData(rawData) {
                    console.log('🔄 Transformando dados dos representantes...');
                    const representativesMap = new Map();
                    const locationMap = new Map();
                    let colorIndex = 0;

                    const stateToAbbrev = {
                        'SAO PAULO': 'SP', 'RIO DE JANEIRO': 'RJ', 'MINAS GERAIS': 'MG', 'BAHIA': 'BA',
                        'PARANA': 'PR', 'RIO GRANDE DO SUL': 'RS', 'PERNAMBUCO': 'PE', 'CEARA': 'CE',
                        'PARA': 'PA', 'SANTA CATARINA': 'SC', 'GOIAS': 'GO', 'MARANHAO': 'MA',
                        'PARAIBA': 'PB', 'AMAZONAS': 'AM', 'ESPIRITO SANTO': 'ES', 'MATO GROSSO': 'MT',
                        'ALAGOAS': 'AL', 'PIAUI': 'PI', 'DISTRITO FEDERAL': 'DF', 'MATO GROSSO DO SUL': 'MS',
                        'SERGIPE': 'SE', 'RIO GRANDE DO NORTE': 'RN', 'RONDONIA': 'RO', 'ACRE': 'AC',
                        'AMAPA': 'AP', 'RORAIMA': 'RR', 'TOCANTINS': 'TO'
                    };

                    // Verificar se os dados estão no formato esperado
                    console.log('📊 Estrutura dos dados recebidos:', Object.keys(rawData));

                    // Verificar se existe a propriedade 'representantes'
                    const dadosRepresentantes = rawData.representantes || rawData;

                    for (const [nomeEmpresa, dadosEmpresa] of Object.entries(dadosRepresentantes)) {
                        // Nova estrutura: dadosEmpresa.estados é um objeto com estados como chaves
                        const codigo = dadosEmpresa.codigo || Math.random().toString();
                        const nome = dadosEmpresa.nome || nomeEmpresa;
                        const contato = dadosEmpresa.contato || {};

                        // Nova estrutura: estados é um objeto, não um array
                        const estados = dadosEmpresa.estados || {};

                        // Coletar todas as cidades de todos os estados
                        const todasCidades = [];
                        const todosEstados = [];

                        for (const [estado, dadosEstado] of Object.entries(estados)) {
                            todosEstados.push(estado);
                            if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                todasCidades.push(...dadosEstado.cidades);
                            }
                        }

                        // Determinar estado principal (primeiro estado ou 'DESCONHECIDO')
                        const estadoPrincipal = todosEstados.length > 0 ? todosEstados[0].trim() : 'DESCONHECIDO';
                        const siglaEstado = stateToAbbrev[estadoPrincipal] || estadoPrincipal.substring(0, 2);

                        const representante = {
                            id: `${nomeEmpresa}_${codigo}`,
                            NomeRepresentante: nome,
                            Contato: contato.nome_contato || '',
                            email: contato.email || '',
                            celular: contato.celular || '',
                            SiglaEstado: siglaEstado,
                            Estado: estadoPrincipal,
                            CidadesAtendidas: todasCidades,
                            CodigoRepresentante: codigo,
                            // Adicionar dados dos estados para uso posterior
                            EstadosDetalhados: estados
                        };

                        representativesMap.set(representante.id, representante);

                        // Atribuir cor ao representante
                        if (!representativeColorMap.has(representante.id)) {
                            // COMENTADO: Lógica de cores especiais removida, usar apenas cores gerais
                            // Verificar se é um representante especial com cor específica
                            // const nomeNormalizado = nomeEmpresa.toLowerCase();
                            // console.log(`🎨 Verificando cor para: ${nomeNormalizado} (${nomeEmpresa})`);
                            
                            // if (specialRepresentativeColors[nomeNormalizado]) {
                            //     representativeColorMap.set(representante.id, specialRepresentativeColors[nomeNormalizado]);
                            //     console.log(`✅ Cor especial atribuída: ${representante.NomeRepresentante} -> ${specialRepresentativeColors[nomeNormalizado]}`);
                            // } else {
                                representativeColorMap.set(representante.id, representativeColors[colorIndex % representativeColors.length]);
                                // console.log(`🎨 Cor padrão atribuída: ${representante.NomeRepresentante} -> ${representativeColors[colorIndex % representativeColors.length]}`);
                                colorIndex++;
                            // }
                        }

                        // Indexar por estado
                        todosEstados.forEach(estado => {
                            const sigla = stateToAbbrev[estado] || estado.substring(0, 2);
                            [estado, sigla].forEach(key => {
                                if (!locationMap.has(key)) locationMap.set(key, new Set());
                                locationMap.get(key).add(representante.id);
                            });
                        });

                        // Indexar por cada cidade e criar mapeamento município-representante
                        // Nova estrutura: cidade+estado -> representante
                        for (const [estado, dadosEstado] of Object.entries(estados)) {
                            if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                dadosEstado.cidades.forEach(cidade => {
                                    const normalizedCidade = normalize(cidade);
                                    const normalizedEstado = normalize(estado);
                                    const cidadeEstadoKey = `${normalizedCidade}-${normalizedEstado}`;

                                    if (!locationMap.has(cidade)) locationMap.set(cidade, new Set());
                                    locationMap.get(cidade).add(representante.id);

                                    // Mapear município+estado para representante (objeto completo)
                                    if (!municipioRepresentativeMap.has(cidadeEstadoKey)) {
                                        municipioRepresentativeMap.set(cidadeEstadoKey, []);
                                    }
                                    municipioRepresentativeMap.get(cidadeEstadoKey).push(representante);

                                    // IMPORTANTE: NÃO mapear apenas por cidade para evitar conflitos entre estados
                                    // Remover esta parte que causava o problema:
                                    // if (!municipioRepresentativeMap.has(normalizedCidade)) {
                                    //     municipioRepresentativeMap.set(normalizedCidade, []);
                                    // }
                                    // municipioRepresentativeMap.get(normalizedCidade).push(representante);
                                });
                            }

                            // Mapear bairros se existirem para o estado SP
                            if (estado === 'SP' && dadosEstado.bairros && Array.isArray(dadosEstado.bairros)) {
                                dadosEstado.bairros.forEach(bairro => {
                                    const normalizedBairro = normalize(bairro);

                                    // Mapear bairro no municipioRepresentativeMap
                                    if (!municipioRepresentativeMap.has(normalizedBairro)) {
                                        municipioRepresentativeMap.set(normalizedBairro, []);
                                    }
                                    municipioRepresentativeMap.get(normalizedBairro).push(representante);

                                    // CORREÇÃO: Também mapear bairro no locationMap para busca geral
                                    if (!locationMap.has(bairro)) locationMap.set(bairro, new Set());
                                    locationMap.get(bairro).add(representante.id);
                                    
                                    // Mapear versão normalizada também
                                    if (!locationMap.has(normalizedBairro)) locationMap.set(normalizedBairro, new Set());
                                    locationMap.get(normalizedBairro).add(representante.id);

                                    console.log(`🏘️ Mapeando bairro "${bairro}" para representante "${nome}"`);
                                });
                            }
                        }
                    }

                    representativesByLocation = locationMap;

                    console.log(`✅ Transformação concluída:`);
                    console.log(`📊 Total de representantes: ${representativesMap.size}`);
                    console.log(`📊 Total de localizações: ${locationMap.size}`);
                    console.log(`📊 Total de mapeamentos município-representante: ${municipioRepresentativeMap.size}`);
                    console.log(`📋 Primeiras 5 chaves do municipioRepresentativeMap:`, Array.from(municipioRepresentativeMap.keys()).slice(0, 5));

                    return Array.from(representativesMap.values());
                }

                // --- FUNÇÃO ESPECIAL PARA SCHIOPPA ---

                function mapSchioppaToAllMunicipios() {
                    // Estados que a SCHIOPPA atende
                    const estadosSchioppa = ['SE', 'RR', 'RN', 'AL', 'RO', 'MA', 'AP', 'AC'];

                    // Encontrar o representante SCHIOPPA
                    const schioppaRep = representativesData.find(rep =>
                        rep.NomeRepresentante && rep.NomeRepresentante.toLowerCase().includes('schioppa')
                    );

                    if (!schioppaRep) {
                        console.log('SCHIOPPA não encontrada nos dados');
                        return;
                    }

                    console.log('Mapeando SCHIOPPA para todos os municípios dos estados:', estadosSchioppa);
                    // COMENTADO: Logs de debug removidos
                    // console.log('SCHIOPPA encontrada:', schioppaRep.NomeRepresentante, 'ID:', schioppaRep.id);
                    // console.log('Cor da SCHIOPPA:', representativeColorMap.get(schioppaRep.id));

                    // Percorrer todos os municípios e mapear os dos estados da SCHIOPPA
                    if (municipiosData && municipiosData.features) {
                        let municipiosMapeados = 0;

                        municipiosData.features.forEach(feature => {
                            const props = feature.properties;
                            let ufMunicipio = '';

                            // Extrair UF do município (diferentes formatos possíveis)
                            if (props.uf_municipio) {
                                // Formato: "UF - Município"
                                ufMunicipio = props.uf_municipio.split(' - ')[0];
                            } else if (props.uf) {
                                ufMunicipio = props.uf;
                            } else if (props.estado) {
                                ufMunicipio = props.estado;
                            }

                            // Se o município pertence a um estado da SCHIOPPA
                            if (estadosSchioppa.includes(ufMunicipio)) {
                                const nomeMunicipio = props.nome || props.name || props.municipio || '';
                                const normalizedName = normalize(nomeMunicipio);

                                if (normalizedName) {
                                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                                    // Não mapear apenas por nome da cidade
                                    const cidadeEstadoKey = `${normalizedName}-${ufMunicipio.toLowerCase()}`;

                                    if (!municipioRepresentativeMap.has(cidadeEstadoKey)) {
                                        municipioRepresentativeMap.set(cidadeEstadoKey, []);
                                    }

                                    // Verificar se SCHIOPPA já está mapeada para este município+estado
                                    const existingReps = municipioRepresentativeMap.get(cidadeEstadoKey);
                                    const jaExiste = existingReps.some(rep => rep.id === schioppaRep.id);

                                    if (!jaExiste) {
                                        municipioRepresentativeMap.get(cidadeEstadoKey).push(schioppaRep);
                                        municipiosMapeados++;
                                    }

                                    // NÃO mapear apenas por cidade para evitar conflitos entre estados
                                    // Remover esta parte que causava o problema:
                                    // if (!municipioRepresentativeMap.has(normalizedName)) {
                                    //     municipioRepresentativeMap.set(normalizedName, []);
                                    // }
                                    // 
                                    // const existingRepsCidade = municipioRepresentativeMap.get(normalizedName);
                                    // const jaExisteCidade = existingRepsCidade.some(rep => rep.id === schioppaRep.id);
                                    // 
                                    // if (!jaExisteCidade) {
                                    //     municipioRepresentativeMap.get(normalizedName).push(schioppaRep);
                                    // }
                                }
                            }
                        });

                        console.log(`SCHIOPPA mapeada para ${municipiosMapeados} municípios`);
                    } else {
                        console.log('Dados de municípios não disponíveis para mapeamento da SCHIOPPA');
                    }
                }

                // --- FUNÇÕES DE BUSCA MELHORADAS ---

                // Função para calcular similaridade entre strings (Levenshtein distance)
                function calculateSimilarity(str1, str2) {
                    const longer = str1.length > str2.length ? str1 : str2;
                    const shorter = str1.length > str2.length ? str2 : str1;
                    
                    if (longer.length === 0) return 1.0;
                    
                    const distance = levenshteinDistance(longer, shorter);
                    return (longer.length - distance) / longer.length;
                }

                // Implementação do algoritmo de Levenshtein
                function levenshteinDistance(str1, str2) {
                    const matrix = [];
                    
                    for (let i = 0; i <= str2.length; i++) {
                        matrix[i] = [i];
                    }
                    
                    for (let j = 0; j <= str1.length; j++) {
                        matrix[0][j] = j;
                    }
                    
                    for (let i = 1; i <= str2.length; i++) {
                        for (let j = 1; j <= str1.length; j++) {
                            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                                matrix[i][j] = matrix[i - 1][j - 1];
                            } else {
                                matrix[i][j] = Math.min(
                                    matrix[i - 1][j - 1] + 1,
                                    matrix[i][j - 1] + 1,
                                    matrix[i - 1][j] + 1
                                );
                            }
                        }
                    }
                    
                    return matrix[str2.length][str1.length];
                }

                // Função para determinar o tipo de busca
                function determineSearchType(query) {
                    const normalizedQuery = normalize(query);
                    
                    // 1. Verificar se é busca por estado (sigla ou nome completo)
                    const statePatterns = [
                        /^(sp|rj|mg|ba|pr|rs|pe|ce|pa|sc|go|ma|pb|am|es|mt|al|pi|df|ms|se|rn|ro|ac|ap|rr|to)$/i,
                        /^(são paulo|rio de janeiro|minas gerais|bahia|paraná|rio grande do sul|pernambuco|ceará|pará|santa catarina|goiás|maranhão|paraíba|amazonas|espírito santo|mato grosso|alagoas|piauí|distrito federal|mato grosso do sul|sergipe|rio grande do norte|rondônia|acre|amapá|roraima|tocantins)$/i
                    ];
                    
                    for (const pattern of statePatterns) {
                        if (pattern.test(normalizedQuery)) {
                            return { type: 'estado', query: normalizedQuery };
                        }
                    }
                    
                    // 2. Verificar se é busca por bairro de São Paulo
                    if (normalizedQuery.includes('vila') || 
                        normalizedQuery.includes('jardim') || 
                        normalizedQuery.includes('jd') ||
                        normalizedQuery.includes('centro') ||
                        normalizedQuery.includes('bairro') ||
                        normalizedQuery.includes('distrito') ||
                        normalizedQuery.includes('cid') ||
                        normalizedQuery.includes('parque') ||
                        normalizedQuery.includes('sao') ||
                        normalizedQuery.includes('jose') ||
                        normalizedQuery.includes('ermelino') ||
                        normalizedQuery.includes('itaquera') ||
                        normalizedQuery.includes('tatuape') ||
                        normalizedQuery.includes('penha') ||
                        normalizedQuery.includes('mooca') ||
                        normalizedQuery.includes('bras') ||
                        normalizedQuery.includes('pari') ||
                        normalizedQuery.includes('belem') ||
                        normalizedQuery.includes('agua') ||
                        normalizedQuery.includes('sapopemba') ||
                        normalizedQuery.includes('aracanduva') ||
                        normalizedQuery.includes('cangaiba') ||
                        normalizedQuery.includes('guaiases') ||
                        normalizedQuery.includes('lajeado') ||
                        normalizedQuery.includes('carrao') ||
                        normalizedQuery.includes('formosa') ||
                        normalizedQuery.includes('carmo') ||
                        normalizedQuery.includes('mateus') ||
                        normalizedQuery.includes('rafael') ||
                        normalizedQuery.includes('iguatemi') ||
                        normalizedQuery.includes('bonifacio')) {
                        return { type: 'bairro', query: normalizedQuery };
                    }
                    
                    // 3. Verificar se é busca por cidade específica
                    return { type: 'cidade', query: normalizedQuery };
                }

                // Função para buscar representantes com busca inteligente e múltiplos critérios
                function searchRepresentatives(query) {
                    if (!query) return [];

                    // Detectar busca com múltiplos critérios (separados por vírgula, "em", "de", etc.)
                    const multiCriteriaPatterns = [
                        /(.+)\s+(em|de|no|na)\s+(.+)/i,  // "representante em São Paulo"
                        /(.+),\s*(.+)/,                   // "Santos, SP" ou "SCHIOPPA, São Paulo"
                        /(.+)\s-\s(.+)/                   // "SCHIOPPA - São Paulo"
                    ];

                    let searchCriteria = [query];
                    let isMultiCriteria = false;

                    // Verificar se é uma busca com múltiplos critérios
                    for (const pattern of multiCriteriaPatterns) {
                        const match = query.match(pattern);
                        if (match) {
                            searchCriteria = [match[1].trim(), match[3] || match[2].trim()];
                            isMultiCriteria = true;
                            console.log(`🔍 Busca multi-critério detectada: "${searchCriteria[0]}" + "${searchCriteria[1]}"`);
                            break;
                        }
                    }

                    const foundRepresentativeIds = new Set();

                    if (isMultiCriteria) {
                        // Busca com múltiplos critérios - combinar resultados
                        const [criterion1, criterion2] = searchCriteria;
                        
                        // Buscar representantes que atendem o primeiro critério
                        const reps1 = searchSingleCriterion(criterion1);
                        const reps2 = searchSingleCriterion(criterion2);
                        
                        // Se um critério é um nome de representante e outro é localização
                        const rep1Names = new Set(reps1.map(r => normalize(r.NomeRepresentante)));
                        const rep2Names = new Set(reps2.map(r => normalize(r.NomeRepresentante)));
                        
                        // Intersecção: representantes que atendem ambos os critérios
                        reps1.forEach(rep => {
                            const repName = normalize(rep.NomeRepresentante);
                            // Verificar se este representante também atende o segundo critério
                            if (reps2.some(r => r.id === rep.id) || 
                                checkRepresentativeLocation(rep, criterion2)) {
                                foundRepresentativeIds.add(rep.id);
                            }
                        });

                        // Se não houve intersecção, tentar união (OR) para resultados mais amplos
                        if (foundRepresentativeIds.size === 0) {
                            console.log('🔍 Nenhuma intersecção encontrada, aplicando busca OR');
                            reps1.forEach(rep => foundRepresentativeIds.add(rep.id));
                            reps2.forEach(rep => foundRepresentativeIds.add(rep.id));
                        }
                    } else {
                        // Busca simples
                        const results = searchSingleCriterion(query);
                        results.forEach(rep => foundRepresentativeIds.add(rep.id));
                    }

                    return representativesData.filter(rep => foundRepresentativeIds.has(rep.id));
                }

                // Função auxiliar para busca por critério único
                function searchSingleCriterion(query) {
                    const searchType = determineSearchType(query);
                    const normalizedQuery = searchType.query;
                    const foundRepresentativeIds = new Set();

                    console.log(`🔍 Tipo de busca: ${searchType.type} para "${query}"`);

                    switch (searchType.type) {
                        case 'estado':
                            // Busca por estado - mais direta
                            for (const [location, repIds] of representativesByLocation.entries()) {
                                if (normalize(location).includes(normalizedQuery)) {
                                    repIds.forEach(id => foundRepresentativeIds.add(id));
                                }
                            }
                            break;

                        case 'bairro':
                            // Busca por bairro - sempre buscar, independente da bairrosLayer estar carregada
                            const bairroResults = searchInBairros(normalizedQuery);
                            bairroResults.forEach(id => foundRepresentativeIds.add(id));
                            
                            // Fallback para busca geral
                            for (const [location, repIds] of representativesByLocation.entries()) {
                                if (normalize(location).includes(normalizedQuery)) {
                                    repIds.forEach(id => foundRepresentativeIds.add(id));
                                }
                            }
                            break;

                        case 'cidade':
                            // Busca por cidade - implementar busca fuzzy inteligente
                            const cidadeResults = searchInCidades(normalizedQuery);
                            cidadeResults.forEach(id => foundRepresentativeIds.add(id));
                            break;
                    }

                    // Busca adicional por nome do representante, contato, email
                    representativesData.forEach(rep => {
                        if (normalize(rep.NomeRepresentante).includes(normalizedQuery) ||
                            normalize(rep.Contato).includes(normalizedQuery) ||
                            normalize(rep.email).includes(normalizedQuery)) {
                            foundRepresentativeIds.add(rep.id);
                        }
                    });

                    return representativesData.filter(rep => foundRepresentativeIds.has(rep.id));
                }

                // Função auxiliar para verificar se um representante atende uma localização
                function checkRepresentativeLocation(representative, locationQuery) {
                    const normalizedLocation = normalize(locationQuery);
                    
                    // Verificar nos estados atendidos
                    if (representative.EstadosDetalhados) {
                        for (const [estado, dadosEstado] of Object.entries(representative.EstadosDetalhados)) {
                            if (normalize(estado).includes(normalizedLocation)) {
                                return true;
                            }
                            
                            // Verificar nas cidades
                            if (dadosEstado.cidades) {
                                for (const cidade of dadosEstado.cidades) {
                                    if (normalize(cidade).includes(normalizedLocation)) {
                                        return true;
                                    }
                                }
                            }
                            
                            // Verificar nos bairros (para SP)
                            if (dadosEstado.bairros) {
                                for (const bairro of dadosEstado.bairros) {
                                    if (normalize(bairro).includes(normalizedLocation)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    
                    return false;
                }

                // --- FUNÇÕES PARA BUSCA MELHORADA ---

                // Gerar sugestões inteligentes
                function generateSuggestions(query) {
                    if (!query || query.length < 2) return [];
                    
                    const suggestions = [];
                    const normalizedQuery = normalize(query);
                    const maxSuggestions = 8;
                    
                    // 1. Estados
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'estados') {
                        const estados = ['São Paulo', 'Rio de Janeiro', 'Minas Gerais', 'Bahia', 'Paraná', 'Rio Grande do Sul', 
                                       'Pernambuco', 'Ceará', 'Pará', 'Santa Catarina', 'Goiás', 'Maranhão', 'Paraíba', 
                                       'Amazonas', 'Espírito Santo', 'Mato Grosso', 'Alagoas', 'Piauí', 'Distrito Federal', 
                                       'Mato Grosso do Sul', 'Sergipe', 'Rio Grande do Norte', 'Rondônia', 'Acre', 'Amapá', 
                                       'Roraima', 'Tocantins'];
                        
                        estados.forEach(estado => {
                            const normalizedEstado = normalize(estado);
                            if (normalizedEstado.includes(normalizedQuery) && suggestions.length < maxSuggestions) {
                                const similarity = calculateSimilarity(normalizedEstado, normalizedQuery);
                                suggestions.push({
                                    type: 'estado',
                                    text: estado,
                                    similarity,
                                    priority: normalizedEstado.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                });
                            }
                        });
                    }
                    
                    // 2. Cidades (baseado nos dados dos representantes)
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'cidades') {
                        const cidadesSet = new Set();
                        representativesData.forEach(rep => {
                            if (rep.EstadosDetalhados) {
                                Object.values(rep.EstadosDetalhados).forEach(estadoData => {
                                    if (estadoData.cidades) {
                                        estadoData.cidades.forEach(cidade => {
                                            const normalizedCidade = normalize(cidade);
                                            if (normalizedCidade.includes(normalizedQuery) && !cidadesSet.has(cidade) && suggestions.length < maxSuggestions) {
                                                cidadesSet.add(cidade);
                                                const similarity = calculateSimilarity(normalizedCidade, normalizedQuery);
                                                suggestions.push({
                                                    type: 'cidade',
                                                    text: cidade,
                                                    similarity,
                                                    priority: normalizedCidade.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                    
                    // 3. Bairros de São Paulo
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'bairros') {
                        const bairrosSet = new Set();
                        representativesData.forEach(rep => {
                            if (rep.EstadosDetalhados && rep.EstadosDetalhados.SP && rep.EstadosDetalhados.SP.bairros) {
                                rep.EstadosDetalhados.SP.bairros.forEach(bairro => {
                                    const normalizedBairro = normalize(bairro);
                                    if (normalizedBairro.includes(normalizedQuery) && !bairrosSet.has(bairro) && suggestions.length < maxSuggestions) {
                                        bairrosSet.add(bairro);
                                        const similarity = calculateSimilarity(normalizedBairro, normalizedQuery);
                                        suggestions.push({
                                            type: 'bairro',
                                            text: bairro + ' (SP)',
                                            originalText: bairro,
                                            similarity,
                                            priority: normalizedBairro.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                        });
                                    }
                                });
                            }
                        });
                    }
                    
                    // 4. Representantes
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'representantes') {
                        representativesData.forEach(rep => {
                            const normalizedRep = normalize(rep.NomeRepresentante);
                            if (normalizedRep.includes(normalizedQuery) && suggestions.length < maxSuggestions) {
                                const similarity = calculateSimilarity(normalizedRep, normalizedQuery);
                                suggestions.push({
                                    type: 'representante',
                                    text: rep.NomeRepresentante,
                                    similarity,
                                    priority: normalizedRep.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                });
                            }
                        });
                    }
                    
                    // 5. Sugestões combinadas (apenas se há texto suficiente)
                    if (query.length >= 4 && suggestions.length < maxSuggestions - 2) {
                        // Sugerir combinações populares
                        const popularCombinations = [
                            'SCHIOPPA em São Paulo',
                            '3L em Bauru',
                            'representantes em SP',
                            'Santos, SP',
                            'Campinas, SP'
                        ];
                        
                        popularCombinations.forEach(combo => {
                            if (normalize(combo).includes(normalizedQuery) && suggestions.length < maxSuggestions) {
                                suggestions.push({
                                    type: 'combinado',
                                    text: combo,
                                    similarity: 0.6,
                                    priority: 1
                                });
                            }
                        });
                    }
                    
                    // Ordenar por prioridade e similaridade
                    return suggestions
                        .sort((a, b) => {
                            if (a.priority !== b.priority) return b.priority - a.priority;
                            return b.similarity - a.similarity;
                        })
                        .slice(0, maxSuggestions);
                }

                // Mostrar sugestões
                function showSuggestions(suggestions) {
                    if (suggestions.length === 0) {
                        hideSuggestions();
                        return;
                    }
                    
                    suggestionsList.innerHTML = '';
                    selectedSuggestionIndex = -1;
                    
                    suggestions.forEach((suggestion, index) => {
                        const item = document.createElement('div');
                        item.className = 'suggestion-item';
                        
                        // Ícone baseado no tipo
                        let icon = 'search';
                        switch(suggestion.type) {
                            case 'estado': icon = 'map'; break;
                            case 'cidade': icon = 'map-pin'; break;
                            case 'bairro': icon = 'home'; break;
                            case 'representante': icon = 'user'; break;
                            case 'combinado': icon = 'link'; break;
                        }
                        
                        item.innerHTML = `
                            <div class="flex items-center gap-2">
                                <i data-lucide="${icon}" class="h-3 w-3 text-gray-400"></i>
                                <span>${suggestion.text}</span>
                            </div>
                            <span class="suggestion-type">${suggestion.type}</span>
                        `;
                        
                        item.addEventListener('click', () => {
                            selectSuggestion(suggestion);
                        });
                        
                        suggestionsList.appendChild(item);
                    });
                    
                    // Adicionar instrução sutil no final das sugestões
                    if (suggestions.length > 0) {
                        const instructionItem = document.createElement('div');
                        instructionItem.className = 'suggestion-instruction text-xs text-gray-500 p-2 border-t border-gray-100 text-center';
                        instructionItem.innerHTML = 'Clique em uma sugestão ou pressione Enter para buscar';
                        suggestionsList.appendChild(instructionItem);
                    }
                    
                    searchSuggestions = suggestions;
                    suggestionsContainer.classList.remove('hidden');
                    
                    // Adicionar classe para indicar que há sugestões
                    searchInput.classList.add('has-suggestions');
                    
                    // Inicializar ícones Lucide para as novas sugestões
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                }

                // Esconder sugestões
                function hideSuggestions() {
                    suggestionsContainer.classList.add('hidden');
                    selectedSuggestionIndex = -1;
                    searchInput.classList.remove('has-suggestions');
                }

                // Selecionar sugestão
                function selectSuggestion(suggestion) {
                    const textToUse = suggestion.originalText || suggestion.text;
                    searchInput.value = textToUse;
                    hideSuggestions();
                    handleSearch();
                    addToRecentSearches(textToUse);
                }

                // Adicionar ao histórico de buscas recentes
                function addToRecentSearches(searchTerm) {
                    if (!searchTerm.trim()) return;
                    
                    // Remove duplicatas e adiciona no início
                    recentSearchesData = recentSearchesData.filter(item => item !== searchTerm);
                    recentSearchesData.unshift(searchTerm);
                    
                    // Limita a 5 itens
                    recentSearchesData = recentSearchesData.slice(0, 5);
                    
                    // Salva no localStorage
                    localStorage.setItem('recentSearches', JSON.stringify(recentSearchesData));
                    
                    updateRecentSearchesDisplay();
                }

                // Atualizar exibição do histórico
                function updateRecentSearchesDisplay() {
                    if (recentSearchesData.length === 0) {
                        recentSearches.classList.add('hidden');
                        return;
                    }
                    
                    recentSearchesList.innerHTML = '';
                    recentSearchesData.forEach(searchTerm => {
                        const item = document.createElement('span');
                        item.className = 'recent-search-item';
                        item.textContent = searchTerm;
                        item.addEventListener('click', () => {
                            searchInput.value = searchTerm;
                            handleSearch();
                        });
                        recentSearchesList.appendChild(item);
                    });
                    
                    recentSearches.classList.remove('hidden');
                }

                // Atualizar destaque das sugestões
                function updateSuggestionHighlight() {
                    const suggestionItems = suggestionsList.querySelectorAll('.suggestion-item');
                    suggestionItems.forEach((item, index) => {
                        if (index === selectedSuggestionIndex) {
                            item.classList.add('highlighted');
                        } else {
                            item.classList.remove('highlighted');
                        }
                    });
                }

                // Função para buscar em bairros de São Paulo
                function searchInBairros(query) {
                    const foundIds = new Set();
                    const normalizedQuery = normalize(query);
                    
                    console.log(`🔍 Buscando bairros para: "${query}" (normalizado: "${normalizedQuery}")`);
                    
                    // MÉTODO 1: Busca direta no municipioRepresentativeMap
                    const directMatch = municipioRepresentativeMap.get(normalizedQuery);
                    if (directMatch && directMatch.length > 0) {
                        directMatch.forEach(rep => {
                            console.log(`✅ Match direto encontrado no municipioRepresentativeMap: "${query}" para representante "${rep.NomeRepresentante}"`);
                            foundIds.add(rep.id);
                        });
                    }
                    
                    // MÉTODO 2: Buscar em todos os representantes que têm bairros mapeados
                    representativesData.forEach(rep => {
                        if (rep.EstadosDetalhados && rep.EstadosDetalhados.SP && rep.EstadosDetalhados.SP.bairros) {
                            const bairros = rep.EstadosDetalhados.SP.bairros;
                            
                            bairros.forEach(bairro => {
                                const normalizedBairro = normalize(bairro);
                                
                                // Busca exata primeiro
                                if (normalizedBairro === normalizedQuery) {
                                    console.log(`✅ Match exato encontrado: "${bairro}" para representante "${rep.NomeRepresentante}"`);
                                    foundIds.add(rep.id);
                                    return;
                                }
                                
                                // Busca por contém (para bairros que começam com a query)
                                if (normalizedBairro.includes(normalizedQuery) && normalizedQuery.length >= 3) {
                                    console.log(`🔍 Match por contém encontrado: "${bairro}" para representante "${rep.NomeRepresentante}"`);
                                    foundIds.add(rep.id);
                                    return;
                                }
                                
                                // Busca por similaridade (Levenshtein)
                                const similarity = calculateSimilarity(normalizedBairro, normalizedQuery);
                                if (similarity > 0.7) { // Threshold de 70% de similaridade
                                    console.log(`🔍 Match similar encontrado: "${bairro}" (${(similarity * 100).toFixed(1)}%) para representante "${rep.NomeRepresentante}"`);
                                    foundIds.add(rep.id);
                                }
                            });
                        }
                    });
                    
                    console.log(`📊 Total de representantes encontrados para bairros: ${foundIds.size}`);
                    return foundIds;
                }

                // Função para buscar em cidades com diferenciação inteligente
                function searchInCidades(query) {
                    const foundIds = new Set();
                    const exactMatches = [];
                    const partialMatches = [];
                    const similarMatches = [];
                    
                    // Coletar todas as cidades únicas com seus estados
                    const cidadesUnicas = new Map(); // cidade -> [estados]
                    
                    representativesData.forEach(rep => {
                        if (rep.EstadosDetalhados) {
                            Object.entries(rep.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                                if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                    dadosEstado.cidades.forEach(cidade => {
                                        const normalizedCidade = normalize(cidade);
                                        if (!cidadesUnicas.has(normalizedCidade)) {
                                            cidadesUnicas.set(normalizedCidade, []);
                                        }
                                        if (!cidadesUnicas.get(normalizedCidade).includes(estado)) {
                                            cidadesUnicas.get(normalizedCidade).push(estado);
                                        }
                                    });
                                }
                            });
                        }
                    });
                    
                    // Classificar as cidades por tipo de match
                    for (const [cidade, estados] of cidadesUnicas.entries()) {
                        // 1. Match exato
                        if (cidade === query) {
                            exactMatches.push({ cidade, estados });
                        }
                        // 2. Match parcial (começa com a query)
                        else if (cidade.startsWith(query) && query.length >= 3) {
                            partialMatches.push({ cidade, estados });
                        }
                        // 3. Match por similaridade
                        else {
                            const similarity = calculateSimilarity(cidade, query);
                            if (similarity > 0.7) { // Threshold de 70% de similaridade
                                similarMatches.push({ cidade, estados, similarity });
                            }
                        }
                    }
                    
                    // Ordenar matches similares por similaridade
                    similarMatches.sort((a, b) => b.similarity - a.similarity);
                    
                    // Processar matches exatos primeiro
                    exactMatches.forEach(({ cidade, estados }) => {
                        const representatives = getRepresentativesByCidade(cidade, estados);
                        representatives.forEach(rep => foundIds.add(rep.id));
                    });
                    
                    // Se não há matches exatos, processar parciais
                    if (exactMatches.length === 0 && partialMatches.length > 0) {
                        partialMatches.forEach(({ cidade, estados }) => {
                            const representatives = getRepresentativesByCidade(cidade, estados);
                            representatives.forEach(rep => foundIds.add(rep.id));
                        });
                    }
                    
                    // Se ainda não há resultados, processar similares
                    if (foundIds.size === 0 && similarMatches.length > 0) {
                        // Limitar a 3 matches similares para evitar poluição
                        similarMatches.slice(0, 3).forEach(({ cidade, estados }) => {
                            const representatives = getRepresentativesByCidade(cidade, estados);
                            representatives.forEach(rep => foundIds.add(rep.id));
                        });
                    }
                    
                    return foundIds;
                }

                // Função para obter representantes por cidade e estados
                function getRepresentativesByCidade(cidade, estados) {
                    const representatives = [];
                    
                    representativesData.forEach(rep => {
                        if (rep.EstadosDetalhados) {
                            Object.entries(rep.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                                if (estados.includes(estado) && dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                    if (dadosEstado.cidades.some(c => normalize(c) === cidade)) {
                                        representatives.push(rep);
                                    }
                                }
                            });
                        }
                    });
                    
                    return representatives;
                }

                // Função para buscar representantes por localização específica
                function getRepresentativesByLocation(location) {
                    const repIds = representativesByLocation.get(location) || new Set();
                    return representativesData.filter(rep => repIds.has(rep.id));
                }

                // --- FUNÇÕES DE INICIALIZAÇÃO ---

                async function initializeApp() {
                    try {
                        const [rawRepData, rawMunicipiosData] = await Promise.all([
                            fetchJsonData(jsonFileUrl),
                            fetchJsonData(municipiosJsonUrl)
                        ]);

                        representativesData = transformRepresentativesData(rawRepData);
                        municipiosData = rawMunicipiosData;

                        // Mapear SCHIOPPA para todos os municípios dos seus estados
                        mapSchioppaToAllMunicipios();

                        // Debug: Verificar estrutura dos dados de municípios
                        if (municipiosData.features && municipiosData.features.length > 0) {
                            console.log('Estrutura do primeiro município:', municipiosData.features[0].properties);
                            console.log('Total de municípios carregados:', municipiosData.features.length);
                            console.log('Propriedades disponíveis:', Object.keys(municipiosData.features[0].properties));
                        }

                        await setupMap();
                        setupEventListeners();
                        
                        // Inicializar funcionalidades de busca melhorada
                        updateRecentSearchesDisplay();
                        
                        // Inicializar ícones Lucide
                        if (typeof lucide !== 'undefined') {
                            lucide.createIcons();
                        }
                        
                        loadingIndicator.classList.add('hidden');
                        defaultMessage.classList.remove('hidden');
                    } catch (error) {
                        console.error("Erro ao inicializar a aplicação:", error);
                        initialMessage.innerHTML = `<p class="text-red-500 text-center">Falha ao carregar os dados. Verifique a conexão.</p>`;
                    }
                }

                async function fetchJsonData(url) {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Não foi possível buscar o arquivo: ${response.statusText}`);
                    return await response.json();
                }

                async function setupMap() {
                    map = L.map('map', { zoomControl: true, attributionControl: false }).setView([-15.78, -47.92], 4);

                    const response = await fetch(brazilStatesGeoJsonUrl);
                    const brazilGeoJson = await response.json();

                    geoJsonLayer = L.geoJson(brazilGeoJson, {
                        style: defaultMapStyle,
                        onEachFeature: onEachStateFeature,
                        interactive: true
                    }).addTo(map);

                    // Configurar a layer dos estados para ter prioridade
                    geoJsonLayer.setZIndex(10);

                    // Carregar e adicionar camada dos bairros de São Paulo
                    try {
                        const bairrosResponse = await fetch(bairrosGeoJsonUrl);
                        const bairrosGeoJson = await bairrosResponse.json();

                        bairrosLayer = L.geoJson(bairrosGeoJson, {
                            style: function (feature) {
                                const bairroName = feature.properties.NOME_DIST;
                                if (bairroName) {
                                    const normalizedBairroName = normalize(bairroName);
                                    
                                    // IMPORTANTE: Buscar representantes considerando o estado atual (SP para bairros)
                                    let representatives = [];
                                    if (viewMode === 'municipios' && currentState && currentState.code === 'SP') {
                                        // Para bairros de SP, usar a chave cidade+estado
                                        const cidadeEstadoKey = `${normalizedBairroName}-SP`;
                                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                                        
                                        // Se não encontrar com chave composta, tentar só o nome (compatibilidade)
                                        if (representatives.length === 0) {
                                            representatives = municipioRepresentativeMap.get(normalizedBairroName) || [];
                                        }
                                    }
                                    // Se não estivermos em SP ou no modo correto, não colorir bairros

                                    if (representatives.length > 0) {
                                        // Se há representantes, usar a cor do primeiro representante
                                        const firstRep = representatives[0];
                                        const color = representativeColorMap.get(firstRep.id) || '#9CA3AF';

                                        return {
                                            color: '#DC2626',        // Vermelho para o contorno
                                            weight: 3,
                                            opacity: 1,
                                            dashArray: '8,6',        // Pontilhado/dashed
                                            fillColor: color,
                                            fillOpacity: 0.7,
                                            // Stroke branco por fora será aplicado via CSS
                                            className: 'bairro-with-rep'
                                        };
                                    }
                                }

                                // Estilo padrão para bairros sem representantes
                                return {
                                    color: '#DC2626',        // Vermelho para o contorno
                                    weight: 2,
                                    opacity: 0.6,
                                    dashArray: '6,4',        // Pontilhado mais sutil
                                    fillColor: '#999',
                                    fillOpacity: 0.2,
                                    className: 'bairro-without-rep'
                                };
                            },
                            onEachFeature: function (feature, layer) {
                                const bairroName = feature.properties.NOME_DIST;
                                if (bairroName) {
                                    // Buscar representantes para este bairro
                                    const normalizedBairroName = normalize(bairroName);
                                    const representatives = municipioRepresentativeMap.get(normalizedBairroName) || [];

                                    // Tooltip com informações do bairro e representantes
                                    let tooltipContent = `<strong>${bairroName}</strong>`;
                                    if (representatives.length > 0) {
                                        tooltipContent += `<br><small>Representantes: ${representatives.length}</small>`;
                                        representatives.forEach((rep, index) => {
                                            const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                                            tooltipContent += `<br><span style="color: ${color}; font-weight: bold;">•</span> ${rep.NomeRepresentante}`;
                                            if (rep.Contato) {
                                                tooltipContent += ` (${rep.Contato})`;
                                            }
                                        });
                                    } else {
                                        tooltipContent += `<br><small style="color: #6B7280;">Sem representantes</small>`;
                                    }

                                    layer.bindTooltip(tooltipContent, {
                                        permanent: false,
                                        direction: 'top',
                                        className: 'bairro-tooltip'
                                    });

                                    // Adicionar evento de clique para zoom na capital de São Paulo
                                    layer.on('click', function (e) {
                                        // Coordenadas aproximadas da capital de São Paulo
                                        const capitalBounds = L.latLngBounds(
                                            [-23.8, -46.8],  // Sudoeste
                                            [-23.4, -46.4]   // Nordeste
                                        );

                                        map.fitBounds(capitalBounds, {
                                            padding: [30, 30],
                                            maxZoom: 10  // Zoom para mostrar toda a capital
                                        });
                                        console.log('🏙️ Zoom aplicado na capital de São Paulo');
                                    });
                                }
                            },
                            interactive: true
                        }).addTo(map);

                        // Configurar a layer dos bairros para ter prioridade menor que os estados
                        bairrosLayer.setZIndex(5);

                        // Inicialmente, os bairros ficam ocultos
                        bairrosLayer.remove();

                        console.log('✅ Camada dos bairros de São Paulo carregada com sucesso');
                    } catch (error) {
                        console.warn('⚠️ Não foi possível carregar a camada dos bairros:', error);
                    }

                    // Adicionar listener global no mapa para interceptar cliques
                    map.on('click', handleGlobalMapClick);

                    map.fitBounds(geoJsonLayer.getBounds());
                }

                function handleGlobalMapClick(e) {
                    const latlng = e.latlng;
                    console.log('Clique global detectado em:', latlng);

                    // Função para verificar se um ponto está dentro de um polígono (ray casting)
                    function pointInPolygon(point, polygon) {
                        const x = point.lat, y = point.lng;
                        let inside = false;

                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            const xi = polygon[i].lat, yi = polygon[i].lng;
                            const xj = polygon[j].lat, yj = polygon[j].lng;

                            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                                inside = !inside;
                            }
                        }
                        return inside;
                    }

                    // Verificar municípios PRIMEIRO se a camada estiver disponível
                    // (mesmo no modo 'states' se os dados estiverem carregados)
                    if (municipiosLayer) {
                        console.log('🔍 Verificando municípios primeiro (dados de municípios disponíveis)');
                        let clickedMunicipio = null;
                        municipiosLayer.eachLayer(layer => {
                            if (layer.getBounds().contains(latlng)) {
                                const feature = layer.feature;
                                if (feature.geometry.type === 'Polygon') {
                                    const coords = feature.geometry.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                    if (pointInPolygon(latlng, coords)) {
                                        clickedMunicipio = layer;
                                    }
                                } else if (feature.geometry.type === 'MultiPolygon') {
                                    for (let polygon of feature.geometry.coordinates) {
                                        const coords = polygon[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                        if (pointInPolygon(latlng, coords)) {
                                            clickedMunicipio = layer;
                                            break;
                                        }
                                    }
                                }
                            }
                        });

                        if (clickedMunicipio) {
                            const props = clickedMunicipio.feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            if (municipioName) {
                                console.log('✅ Clique interceptado em MUNICÍPIO:', municipioName);
                                console.log('📍 Estado atual:', currentState);
                                console.log('📍 ViewMode:', viewMode);

                                // Verificar a qual estado o município pertence
                                const municipioState = getMunicipioState(props);
                                console.log('📍 Estado do município:', municipioState);

                                // Se estamos no modo 'states' e não temos estado selecionado,
                                // ou se o município pertence a um estado diferente do atual
                                if ((viewMode === 'states' && !currentState) || 
                                    (currentState && municipioState && municipioState !== currentState.code)) {
                                    console.log('🔄 Carregando estado para visualizar município...');

                                    // Encontrar o estado correto no mapa
                                    const targetStateLayer = findStateLayerByCode(municipioState);
                                    if (targetStateLayer) {
                                        console.log('🔄 Carregando estado:', municipioState);
                                        
                                        // Armazenar o nome do município para filtrar após carregar o estado
                                        const targetMunicipio = municipioName;
                                        
                                        const fakeEvent = {
                                            target: targetStateLayer,
                                            latlng: latlng,
                                            originalEvent: e.originalEvent
                                        };
                                        
                                        // Carregar o estado e depois filtrar o município específico
                                        handleStateClick(fakeEvent);
                                        
                                        // Aguardar o carregamento do estado e depois filtrar pelo município
                                        setTimeout(() => {
                                            console.log('🎯 Filtrando município após carregar estado:', targetMunicipio);
                                            filterByMunicipio(targetMunicipio);
                                        }, 800); // Delay para garantir que o estado foi carregado
                                        return;
                                    }
                                }

                                // Reset do município selecionado anterior
                                if (selectedMunicipioLayer) {
                                    municipiosLayer.resetStyle(selectedMunicipioLayer);
                                }

                                // Selecionar o novo município
                                selectedMunicipioLayer = clickedMunicipio;
                                selectedMunicipioLayer.setStyle(municipioSelectedStyle);

                                // Mostrar os representantes do município
                                filterByMunicipio(municipioName);

                                // Scroll para os resultados
                                document.getElementById('results-container').scrollIntoView({ behavior: 'smooth' });
                                return; // Parar aqui, não processar estado
                            }
                        } else {
                            console.log('❌ Nenhum município encontrado no clique - verificando se é clique em estado diferente');

                            // Se não encontrou município, verificar se é clique em estado diferente
                            let clickedState = null;
                            geoJsonLayer.eachLayer(layer => {
                                if (layer.getBounds().contains(latlng)) {
                                    const feature = layer.feature;
                                    if (feature.geometry.type === 'Polygon') {
                                        const coords = feature.geometry.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                        if (pointInPolygon(latlng, coords)) {
                                            clickedState = layer;
                                        }
                                    } else if (feature.geometry.type === 'MultiPolygon') {
                                        for (let polygon of feature.geometry.coordinates) {
                                            const coords = polygon[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                            if (pointInPolygon(latlng, coords)) {
                                                clickedState = layer;
                                                break;
                                            }
                                        }
                                    }
                                }
                            });

                            if (clickedState) {
                                const clickedStateCode = getStateCode(clickedState.feature.properties);
                                const clickedStateName = clickedState.feature.properties.nome || clickedState.feature.properties.name || clickedState.feature.properties.NAME;

                                // Verificar se é um estado diferente do atual
                                if (currentState && currentState.code !== clickedStateCode) {
                                    console.log('🔄 Clique em estado diferente detectado:', clickedStateName, '(', clickedStateCode, ')');
                                    console.log('🔄 Estado atual:', currentState.name, '(', currentState.code, ')');

                                    // Fazer reset completo e carregar novo estado
                                    const fakeEvent = {
                                        target: clickedState,
                                        latlng: latlng,
                                        originalEvent: e.originalEvent
                                    };
                                    handleStateClick(fakeEvent);
                                    return;
                                }
                            }
                        }
                    }

                    // Se não clicou em município ou não estamos no modo municípios, verificar estados
                    console.log('🔍 Verificando estados...');
                    let clickedState = null;
                    geoJsonLayer.eachLayer(layer => {
                        if (layer.getBounds().contains(latlng)) {
                            // Verificação mais precisa usando geometria
                            const feature = layer.feature;
                            if (feature.geometry.type === 'Polygon') {
                                const coords = feature.geometry.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                if (pointInPolygon(latlng, coords)) {
                                    clickedState = layer;
                                }
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                for (let polygon of feature.geometry.coordinates) {
                                    const coords = polygon[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                    if (pointInPolygon(latlng, coords)) {
                                        clickedState = layer;
                                        break;
                                    }
                                }
                            }
                        }
                    });

                    // Se clicou em um estado, processar como estado
                    if (clickedState) {
                        console.log('✅ Clique interceptado em ESTADO');

                        // Verificar se é um clique em um estado diferente do atual
                        const clickedStateCode = getStateCode(clickedState.feature.properties);
                        const clickedStateName = clickedState.feature.properties.nome || clickedState.feature.properties.name || clickedState.feature.properties.NAME;

                        if (currentState && currentState.code !== clickedStateCode) {
                            console.log('🔄 Clique em estado diferente detectado. Fazendo reset completo...');
                            // É um clique em um estado diferente - fazer reset completo
                            const fakeEvent = {
                                target: clickedState,
                                latlng: latlng,
                                originalEvent: e.originalEvent
                            };
                            handleStateClick(fakeEvent);
                        } else if (!currentState) {
                            // Primeiro clique em um estado
                            const fakeEvent = {
                                target: clickedState,
                                latlng: latlng,
                                originalEvent: e.originalEvent
                            };
                            handleStateClick(fakeEvent);
                        }
                    }
                }

                function setupEventListeners() {
                    let debounceTimeout;
                    let suggestionTimeout;
                    
                    // Input da busca com sugestões
                    searchInput.addEventListener('input', function () {
                        const query = this.value.trim();
                        
                        // Mostrar/esconder botão de limpar
                        if (query) {
                            clearSearchButton.classList.remove('hidden');
                        } else {
                            clearSearchButton.classList.add('hidden');
                            hideSuggestions();
                        }
                        
                        // Gerar sugestões com debounce menor
                        clearTimeout(suggestionTimeout);
                        if (query.length >= 2) {
                            suggestionTimeout = setTimeout(() => {
                                const suggestions = generateSuggestions(query);
                                showSuggestions(suggestions);
                            }, 150);
                        } else {
                            hideSuggestions();
                        }
                        
                        // Remover busca automática - só buscar quando usuário clicar ou pressionar Enter
                        clearTimeout(debounceTimeout);
                    });
                    
                    // Navegação por teclado nas sugestões
                    searchInput.addEventListener('keydown', function(e) {
                        if (searchSuggestions.length === 0) return;
                        
                        switch(e.key) {
                            case 'ArrowDown':
                                e.preventDefault();
                                selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, searchSuggestions.length - 1);
                                updateSuggestionHighlight();
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                                updateSuggestionHighlight();
                                break;
                            case 'Enter':
                                e.preventDefault();
                                if (selectedSuggestionIndex >= 0) {
                                    selectSuggestion(searchSuggestions[selectedSuggestionIndex]);
                                } else if (searchSuggestions.length === 0 || suggestionsContainer.classList.contains('hidden')) {
                                    // Só executa busca se não há sugestões visíveis
                                    hideSuggestions();
                                    handleSearch();
                                    if (this.value.trim()) {
                                        addToRecentSearches(this.value.trim());
                                    }
                                }
                                // Se há sugestões visíveis, não faz nada - usuário deve escolher uma sugestão
                                break;
                            case 'Escape':
                                hideSuggestions();
                                break;
                        }
                    });
                    
                    // Focus no input para mostrar histórico
                    searchInput.addEventListener('focus', function() {
                        if (!this.value && recentSearchesData.length > 0) {
                            updateRecentSearchesDisplay();
                        }
                    });
                    
                    // Botão de limpar busca
                    clearSearchButton.addEventListener('click', function() {
                        searchInput.value = '';
                        clearSearchButton.classList.add('hidden');
                        hideSuggestions();
                        resetView(true);
                        searchInput.focus();
                    });
                    
                    // Filtros de busca
                    searchFilters.forEach(filter => {
                        filter.addEventListener('click', function() {
                            // Atualizar filtro ativo
                            searchFilters.forEach(f => f.classList.remove('active'));
                            this.classList.add('active');
                            currentSearchFilter = this.dataset.filter;
                            
                            // Regenerar sugestões se há texto
                            if (searchInput.value.trim().length >= 2) {
                                const suggestions = generateSuggestions(searchInput.value.trim());
                                showSuggestions(suggestions);
                            }
                            
                            // Re-executar busca se há resultados
                            if (searchInput.value.trim()) {
                                handleSearch();
                            }
                        });
                    });
                    
                    // Clique fora das sugestões para esconder (com delay para dar tempo de clicar)
                    document.addEventListener('click', function(e) {
                        if (!suggestionsContainer.contains(e.target) && e.target !== searchInput) {
                            // Pequeno delay para permitir cliques nas sugestões
                            setTimeout(() => {
                                if (!suggestionsContainer.contains(document.activeElement)) {
                                    hideSuggestions();
                                    recentSearches.classList.add('hidden');
                                }
                            }, 100);
                        }
                    });

                    backButton.addEventListener('click', resetView);

                    // Event listener para o botão de reset zoom
                    const resetZoomBtn = document.getElementById('reset-zoom-btn');
                    resetZoomBtn.addEventListener('click', function () {
                        resetView(false); // false para não limpar a busca
                    });

                    // Event listener para o botão de maximizar mapa
                    const maximizeMapBtn = document.getElementById('maximize-map-btn');
                    maximizeMapBtn.addEventListener('click', function () {
                        toggleMapMaximize();
                    });
                }

                // --- ESTILOS DO MAPA ---

                const defaultMapStyle = { fillColor: "#3b82f6", weight: 1, opacity: 1, color: 'white', fillOpacity: 0.7 };
                const highlightMapStyle = { weight: 0, color: '#fbbf24', fillOpacity: 0.9 };
                const selectedMapStyle = { fillColor: "#fbbf24", fillOpacity: 1 };
                const municipioSelectedStyle = { fillColor: "#fbbf24", weight: 2, opacity: 1, color: '#f59e0b', fillOpacity: 0.9 };

                // Função para obter estilo do município baseado no representante
                function getMunicipioStyleByRepresentative(municipioName) {
                    const normalizedName = normalize(municipioName);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    // Buscar representantes considerando o estado atual apenas quando estamos visualizando municípios
                    let representatives = [];
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        const normalizedEstado = normalize(currentState.code);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                        
                    } else {
                        // IMPORTANTE: Não fazer busca apenas por cidade para evitar conflitos
                        // Se não temos estado específico, não podemos determinar qual cidade específica
                        representatives = [];
                    }

                    if (representatives.length === 0) {
                        // Município sem representante - cor azul padrão
                        return {
                            fillColor: "#3b82f6",
                            weight: 1,
                            opacity: 1,
                            color: 'white',
                            fillOpacity: 0.6
                        };
                    }

                    // Se há múltiplos representantes, usar a cor do primeiro
                    const primaryRepresentative = representatives[0];
                    const color = representativeColorMap.get(primaryRepresentative.id) || '#3b82f6';

                    return {
                        fillColor: color,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: representatives.length > 1 ? 0.8 : 0.6 // Mais opaco se múltiplos representantes
                    };
                }

                // Função para obter estilo de destaque do município
                function getMunicipioHighlightStyle(municipioName) {
                    const normalizedName = normalize(municipioName);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    // Buscar representantes considerando o estado atual apenas quando estamos visualizando municípios
                    let representatives = [];
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        const normalizedEstado = normalize(currentState.code);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                    } else {
                        // IMPORTANTE: Não fazer busca apenas por cidade para evitar conflitos
                        // Se não temos estado específico, não podemos determinar qual cidade específica
                        representatives = [];
                    }

                    if (representatives.length === 0) {
                        return { weight: 0, color: '#3b82f6', fillOpacity: 0.8 };
                    }

                    const primaryRepresentative = representatives[0];
                    const color = representativeColorMap.get(primaryRepresentative.id) || '#3b82f6';

                    return {
                        weight: 0,
                        color: color,
                        fillOpacity: 0.9
                    };
                }

                // Função para criar/atualizar a legenda
                function updateLegend(stateRepresentatives = []) {
                    const legendElement = document.getElementById('legend');
                    const legendItemsElement = document.getElementById('legend-items');

                    if (!legendElement || !legendItemsElement) return;

                    // Limpar itens existentes
                    legendItemsElement.innerHTML = '';

                    if (stateRepresentatives.length === 0) {
                        legendElement.classList.add('hidden');
                        return;
                    }

                    // Criar itens da legenda
                    stateRepresentatives.forEach(rep => {
                        const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                        const legendItem = document.createElement('div');
                        legendItem.className = 'flex items-center text-xs text-gray-700';
                        legendItem.innerHTML = `
                        <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${color};"></div>
                        <span class="truncate" title="${rep.NomeRepresentante}">${rep.NomeRepresentante}</span>
                    `;
                        legendItemsElement.appendChild(legendItem);
                    });

                    legendElement.classList.remove('hidden');
                }

                // --- FUNÇÕES DO MAPA DE ESTADOS ---

                function getStateCode(properties) {
                    // Baseado na estrutura real do uf.json
                    // Priorizar UF_05 que contém a sigla do estado (ex: "CE", "AC", "BA")
                    return properties.UF_05 || properties.uf || properties.sigla ||
                        properties.SIGLA || properties.UF ||
                        // Fallback para nome completo se não encontrar sigla
                        properties.NOME_UF || properties.nome || properties.NOME ||
                        properties.name || properties.NAME;
                }

                function onEachStateFeature(feature, layer) {
                    layer.on({
                        mouseover: e => {
                            if (e.target !== selectedStateLayer && viewMode === 'states') {
                                e.target.setStyle(highlightMapStyle);
                            }
                        },
                        mouseout: e => {
                            if (e.target !== selectedStateLayer && viewMode === 'states') {
                                geoJsonLayer.resetStyle(e.target);
                            }
                        }
                        // Removemos o click handler - será tratado pelo listener global
                    });
                }

                function handleStateClick(e) {
                    const properties = e.target.feature.properties;
                    let stateCode = getStateCode(properties);
                    let stateName = properties.nome || properties.name || properties.NAME;

                    console.log('🎯 Estado selecionado:', stateName, stateCode);

                    // Reset completo ANTES de qualquer operação
                    // Reset do estado anterior se existir
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                    }

                    // Remove municípios anteriores se existirem
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    // Reset do município selecionado
                    selectedMunicipioLayer = null;

                    // Limpar resultados e legenda
                    showInitialMessage();
                    updateLegend([]);

                    // Seleciona o novo estado
                    selectedStateLayer = e.target;
                    selectedStateLayer.setStyle(selectedMapStyle);
                    currentState = { code: stateCode, name: stateName, layer: e.target };

                    // Aplicar zoom no estado
                    const stateBounds = e.target.getBounds();
                    console.log('🔍 Aplicando zoom no estado:', stateName, 'Bounds:', stateBounds);

                    map.fitBounds(stateBounds, {
                        padding: [25, 25],
                        maxZoom: 8  // Limitar zoom máximo para não ficar muito próximo
                    });

                    // Aguardar um pouco para garantir que o zoom seja aplicado antes de carregar municípios
                    setTimeout(() => {
                        // Mostra municípios e filtra representantes após o zoom
                        showMunicipios(stateCode, stateName, e.target);
                        filterByState(stateCode);
                    }, 300); // 300ms de delay para garantir
                }

                // Filtrar municípios apenas do estado selecionado
                function showMunicipios(stateCode, stateName, stateLayer) {
                    console.log(`🔍 Carregando municípios para o estado: ${stateName} (${stateCode})`);

                    // Filtrar municípios do estado usando múltiplos critérios
                    const estadoMunicipios = municipiosData.features.filter(feature => {
                        const props = feature.properties;

                        // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio (formato: "UF - Município")
                        let municipioState = props.uf || props.estado || props.sigla_uf ||
                            props.UF || props.ESTADO || props.cd_geocuf;

                        // Se não encontrou, tentar extrair do uf_municipio
                        if (!municipioState && props.uf_municipio) {
                            const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                            if (match) {
                                municipioState = match[1];
                            }
                        }

                        // Comparar com código e nome do estado
                        const pertenceAoEstado = municipioState === stateCode ||
                            municipioState === stateName ||
                            normalize(municipioState) === normalize(stateCode) ||
                            normalize(municipioState) === normalize(stateName);

                        if (pertenceAoEstado) {
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            console.log(`✅ Município ${municipioName} pertence ao estado ${stateName}`);
                        }

                        return pertenceAoEstado;
                    });

                    if (estadoMunicipios.length === 0) {
                        console.log('❌ Nenhum município encontrado para:', stateCode, stateName);
                        console.log('Propriedades disponíveis no primeiro município:',
                            municipiosData.features[0]?.properties);
                        return;
                    }

                    console.log(`✅ Encontrados ${estadoMunicipios.length} municípios para ${stateName}`);

                    // Remover layer de municípios anterior se existir
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    // Limpar labels antigos dos municípios
                    if (window.municipioLabels) {
                        window.municipioLabels.forEach(labelMarker => {
                            // Remover o marcador do label do mapa
                            if (labelMarker && map.hasLayer(labelMarker)) {
                                map.removeLayer(labelMarker);
                            }
                        });
                        window.municipioLabels = [];
                    }

                    // Criar layer dos municípios com cores por representante
                    municipiosLayer = L.geoJson(estadoMunicipios, {
                        style: feature => {
                            const municipioName = feature.properties.name || feature.properties.nome || feature.properties.municipio || feature.properties.description;
                            return getMunicipioStyleByRepresentative(municipioName);
                        },
                        onEachFeature: onEachMunicipioFeature,
                        interactive: true
                    }).addTo(map);

                    // Configurar a layer dos municípios para ter prioridade sobre os estados quando no modo municípios
                    municipiosLayer.setZIndex(15);

                    // Forçar atualização dos estilos para garantir que as cores estejam corretas
                    setTimeout(() => {
                        if (municipiosLayer) {
                            municipiosLayer.eachLayer(layer => {
                                const props = layer.feature.properties;
                                const municipioName = props.name || props.nome || props.municipio || props.description;
                                layer.setStyle(getMunicipioStyleByRepresentative(municipioName));
                            });
                        }
                    }, 100);

                    // Não mostrar legenda quando apenas o estado é selecionado
                    // A legenda só aparecerá quando um município específico for clicado
                    updateLegend([]);

                    viewMode = 'municipios';
                    mainTitle.textContent = `Municípios de ${stateName || stateCode} - Clique em um município para ver os representantes`;
                    backButton.classList.remove('hidden');

                    // Se for São Paulo, mostrar os bairros
                    if (stateCode === 'SP' || stateName === 'SAO PAULO') {
                        if (bairrosLayer) {
                            // Atualizar estilos dos bairros baseado no estado atual
                            updateBairrosStyles();
                            map.addLayer(bairrosLayer);
                            console.log('🏘️ Bairros de São Paulo adicionados ao mapa');
                        }
                    } else {
                        // Se não for SP, remover os bairros se estiverem visíveis
                        if (bairrosLayer && map.hasLayer(bairrosLayer)) {
                            map.removeLayer(bairrosLayer);
                            console.log('🏘️ Bairros removidos do mapa (não é SP)');
                        }
                    }

                    console.log(`🎯 Modo municípios ativado para ${stateName}. Municípios carregados: ${estadoMunicipios.length}`);
                }

                // Função para atualizar estilos da camada de bairros baseado no estado atual
                function updateBairrosStyles() {
                    if (!bairrosLayer) return;
                    
                    bairrosLayer.eachLayer(function(layer) {
                        const feature = layer.feature;
                        const bairroName = feature.properties.NOME_DIST;
                        
                        if (bairroName) {
                            const normalizedBairroName = normalize(bairroName);
                            
                            // IMPORTANTE: Buscar representantes considerando o estado atual (SP para bairros)
                            let representatives = [];
                            if (viewMode === 'municipios' && currentState && currentState.code === 'SP') {
                                // Para bairros de SP, usar a chave cidade+estado
                                const cidadeEstadoKey = `${normalizedBairroName}-SP`;
                                representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                                
                                // Se não encontrar com chave composta, tentar só o nome (compatibilidade)
                                if (representatives.length === 0) {
                                    representatives = municipioRepresentativeMap.get(normalizedBairroName) || [];
                                }
                            }
                            
                            if (representatives.length > 0) {
                                // Se há representantes, usar a cor do primeiro representante
                                const firstRep = representatives[0];
                                const color = representativeColorMap.get(firstRep.id) || '#9CA3AF';

                                layer.setStyle({
                                    color: '#DC2626',        // Vermelho para o contorno
                                    weight: 3,
                                    opacity: 1,
                                    dashArray: '8,6',        // Pontilhado/dashed
                                    fillColor: color,
                                    fillOpacity: 0.7,
                                });
                            } else {
                                // Estilo padrão para bairros sem representantes
                                layer.setStyle({
                                    color: '#DC2626',        // Vermelho para o contorno
                                    weight: 2,
                                    opacity: 0.6,
                                    dashArray: '12,8',       // Mais pontilhado
                                    fillColor: '#f3f4f6',   // Cinza claro
                                    fillOpacity: 0.3,
                                });
                            }
                        }
                    });
                }

                function zoomToMunicipio(municipioName, stateName) {
                    // Primeiro, garantir que os municípios do estado estão carregados
                    const stateCode = getStateCodeByName(stateName);
                    if (!stateCode) return false;

                    // Encontrar e selecionar o estado primeiro
                    const stateFeature = geoJsonLayer.getLayers().find(layer => {
                        const props = layer.feature.properties;
                        const layerStateCode = getStateCode(props);
                        const layerStateName = props.nome || props.name || props.NAME;

                        return layerStateCode === stateCode ||
                            normalize(layerStateName) === normalize(stateName);
                    });

                    if (!stateFeature) {
                        console.log('Estado não encontrado:', stateName, stateCode);
                        return false;
                    }

                    // Reset do estado anterior se existir
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                    }

                    // Remove municípios anteriores se existirem
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    // Reset do município selecionado
                    selectedMunicipioLayer = null;

                    // Seleciona o estado
                    selectedStateLayer = stateFeature;
                    selectedStateLayer.setStyle(selectedMapStyle);
                    currentState = { code: stateCode, name: stateName, layer: stateFeature };

                    // Filtrar municípios do estado
                    const estadoMunicipios = municipiosData.features.filter(feature => {
                        const props = feature.properties;
                        let municipioState = props.uf || props.estado || props.sigla_uf ||
                            props.UF || props.ESTADO || props.cd_geocuf;

                        // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                        if (!municipioState && props.uf_municipio) {
                            const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                            if (match) {
                                municipioState = match[1];
                            }
                        }

                        return municipioState === stateCode ||
                            municipioState === stateName ||
                            normalize(municipioState) === normalize(stateCode) ||
                            normalize(municipioState) === normalize(stateName);
                    });

                    if (estadoMunicipios.length === 0) {
                        console.log('Nenhum município encontrado para o estado:', stateName, stateCode);
                        return false;
                    }

                    // Encontrar o município específico
                    const targetMunicipio = estadoMunicipios.find(feature => {
                        const props = feature.properties;
                        const name = props.name || props.nome || props.municipio || props.description;
                        return normalize(name) === normalize(municipioName);
                    });

                    if (!targetMunicipio) {
                        console.log('Município não encontrado:', municipioName, 'no estado:', stateName);
                        // Mesmo assim, mostrar os municípios do estado
                        showMunicipios(stateCode, stateName, stateFeature);
                        return false;
                    }

                    // Criar layer com todos os municípios do estado
                    municipiosLayer = L.geoJson(estadoMunicipios, {
                        style: feature => {
                            const name = feature.properties.name || feature.properties.nome || feature.properties.municipio || feature.properties.description;
                            return getMunicipioStyleByRepresentative(name);
                        },
                        onEachFeature: onEachMunicipioFeature
                    }).addTo(map);

                    // Fazer zoom no município específico
                    const municipioBounds = L.geoJson(targetMunicipio).getBounds();
                    map.fitBounds(municipioBounds, { padding: [50, 50] });

                    // Destacar o município
                    const municipioLayer = municipiosLayer.getLayers().find(layer => {
                        const props = layer.feature.properties;
                        const name = props.name || props.nome || props.municipio || props.description;
                        return normalize(name) === normalize(municipioName);
                    });

                    if (municipioLayer) {
                        selectedMunicipioLayer = municipioLayer;
                        selectedMunicipioLayer.setStyle(municipioSelectedStyle);
                    }

                    // Obter representantes do estado e atualizar legenda
                    const stateRepresentatives = representativesData.filter(rep =>
                        rep.SiglaEstado === stateCode ||
                        normalize(rep.Estado) === normalize(stateName)
                    );
                    updateLegend(stateRepresentatives);

                    viewMode = 'municipios';
                    mainTitle.textContent = `Município: ${municipioName} - ${stateName}`;
                    backButton.classList.remove('hidden');

                    return true;
                }

                function getStateCodeByName(stateName) {
                    const stateToAbbrev = {
                        'SAO PAULO': 'SP', 'RIO DE JANEIRO': 'RJ', 'MINAS GERAIS': 'MG', 'BAHIA': 'BA',
                        'PARANA': 'PR', 'RIO GRANDE DO SUL': 'RS', 'PERNAMBUCO': 'PE', 'CEARA': 'CE',
                        'PARA': 'PA', 'SANTA CATARINA': 'SC', 'GOIAS': 'GO', 'MARANHAO': 'MA',
                        'PARAIBA': 'PB', 'AMAZONAS': 'AM', 'ESPIRITO SANTO': 'ES', 'MATO GROSSO': 'MT',
                        'ALAGOAS': 'AL', 'PIAUI': 'PI', 'DISTRITO FEDERAL': 'DF', 'MATO GROSSO DO SUL': 'MS',
                        'SERGIPE': 'SE', 'RIO GRANDE DO NORTE': 'RN', 'RONDONIA': 'RO', 'ACRE': 'AC',
                        'AMAPA': 'AP', 'RORAIMA': 'RR', 'TOCANTINS': 'TO'
                    };

                    const normalizedStateName = normalize(stateName).toUpperCase();
                    const stateCode = stateToAbbrev[normalizedStateName];

                    console.log('🔍 Convertendo nome do estado:', stateName, '->', normalizedStateName, '->', stateCode);

                    return stateCode || null;
                }

                // Função para obter o estado de um município baseado nas propriedades do GeoJSON
                function getMunicipioState(props) {
                    // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio (formato: "UF - Município")
                    let municipioState = props.uf || props.estado || props.sigla_uf ||
                        props.UF || props.ESTADO || props.cd_geocuf;

                    // Se não encontrou, tentar extrair do uf_municipio
                    if (!municipioState && props.uf_municipio) {
                        // Tentar diferentes formatos
                        // Formato: "UF - Município" (ex: "SP - São Paulo")
                        let match = props.uf_municipio.match(/^([A-Z]{2})\s*-\s*/);
                        if (match) {
                            municipioState = match[1];
                        } else {
                            // Formato: "Estado - Município" (ex: "Rio Grande do Sul - Arroio do Tigre")
                            match = props.uf_municipio.match(/^([^-]+)\s*-\s*/);
                            if (match) {
                                const estadoNome = match[1].trim();
                                // Converter nome do estado para sigla
                                municipioState = getStateCodeByName(estadoNome);
                            }
                        }
                    }

                    console.log('🔍 Propriedades do município:', props);
                    console.log('🔍 Estado extraído:', municipioState);

                    return municipioState;
                }

                // Função para encontrar a layer de um estado pelo código
                function findStateLayerByCode(stateCode) {
                    let targetLayer = null;
                    geoJsonLayer.eachLayer(layer => {
                        const layerStateCode = getStateCode(layer.feature.properties);
                        if (layerStateCode === stateCode) {
                            targetLayer = layer;
                        }
                    });
                    return targetLayer;
                }

                function onEachMunicipioFeature(feature, layer) {
                    const props = feature.properties;
                    const municipioName = props.name || props.nome || props.municipio || props.description;
                    const normalizedName = normalize(municipioName);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    // Buscar representantes considerando o estado atual apenas quando estamos visualizando municípios
                    let representatives = [];
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        const normalizedEstado = normalize(currentState.code);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                    } else {
                        // IMPORTANTE: Não fazer busca apenas por cidade para evitar conflitos
                        // Se não temos estado específico, não podemos determinar qual cidade específica
                        representatives = [];
                    }

                    layer.on({
                        mouseover: e => {
                            if (e.target !== selectedMunicipioLayer) {
                                e.target.setStyle(getMunicipioHighlightStyle(municipioName));
                            }
                        },
                        mouseout: e => {
                            if (e.target !== selectedMunicipioLayer) {
                                municipiosLayer.resetStyle(e.target);
                            }
                        }
                        // Removemos o click handler - será tratado pelo listener global
                    });

                    // Tooltip com informações do município e representantes
                    let tooltipContent = `<strong>${municipioName}</strong>`;
                    if (representatives.length > 0) {
                        tooltipContent += `<br><small>Representantes: ${representatives.length}</small>`;
                        representatives.slice(0, 2).forEach(rep => {
                            const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                            tooltipContent += `<br><span style="color: ${color}; font-weight: bold;">•</span> ${rep.NomeRepresentante}`;
                        });
                        if (representatives.length > 2) {
                            tooltipContent += `<br>... e mais ${representatives.length - 2}`;
                        }
                    } else {
                        tooltipContent += `<br><small style="color: #6B7280;"></small>`;
                    }

                    layer.bindTooltip(tooltipContent, {
                        permanent: false,
                        direction: 'top',
                        className: 'municipio-tooltip'
                    });

                    // Adicionar label com nome do município centralizado
                    // addMunicipioLabel(layer, municipioName); // Labels removidos conforme solicitado
                }

                function filterByMunicipio(municipioName) {
                    console.log(`🔍 Buscando representantes para o município: ${municipioName}`);
                    console.log(`📍 ViewMode: ${viewMode}, CurrentState:`, currentState);

                    // Usar o mapeamento normalizado para buscar representantes
                    const normalizedName = normalize(municipioName);
                    console.log(`📍 Nome normalizado: ${normalizedName}`);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    let representatives = [];
                    let estadoMunicipio = null;

                    // Se estamos em um estado específico e visualizando municípios, usar cidade+estado
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        estadoMunicipio = currentState.code;
                        const normalizedEstado = normalize(estadoMunicipio);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                        console.log('📍 Buscando por cidade+estado (estado selecionado):', cidadeEstadoKey);
                    } else {
                        // NOVA LÓGICA: Se não temos estado selecionado, tentar determinar o estado do município
                        console.log('🔍 Estado não selecionado, tentando determinar estado do município...');
                        
                        // Buscar o município nos dados geográficos para determinar seu estado
                        if (municipiosData && municipiosData.features) {
                            const municipioFeature = municipiosData.features.find(feature => {
                                const props = feature.properties;
                                const name = props.name || props.nome || props.municipio || props.description;
                                return normalize(name) === normalizedName;
                            });

                            if (municipioFeature) {
                                const props = municipioFeature.properties;
                                // Extrair estado do uf_municipio (formato: "Estado - Cidade")
                                if (props.uf_municipio) {
                                    const ufMunicipio = props.uf_municipio.split(' - ')[0];
                                    // Converter nome do estado para sigla
                                    const stateToAbbrev = {
                                        'São Paulo': 'SP', 'Rio de Janeiro': 'RJ', 'Minas Gerais': 'MG', 'Bahia': 'BA',
                                        'Paraná': 'PR', 'Rio Grande do Sul': 'RS', 'Pernambuco': 'PE', 'Ceará': 'CE',
                                        'Pará': 'PA', 'Santa Catarina': 'SC', 'Goiás': 'GO', 'Maranhão': 'MA',
                                        'Paraíba': 'PB', 'Amazonas': 'AM', 'Espírito Santo': 'ES', 'Mato Grosso': 'MT',
                                        'Alagoas': 'AL', 'Piauí': 'PI', 'Distrito Federal': 'DF', 'Mato Grosso do Sul': 'MS',
                                        'Sergipe': 'SE', 'Rio Grande do Norte': 'RN', 'Rondônia': 'RO', 'Acre': 'AC',
                                        'Amapá': 'AP', 'Roraima': 'RR', 'Tocantins': 'TO'
                                    };
                                    estadoMunicipio = stateToAbbrev[ufMunicipio] || ufMunicipio;
                                    console.log(`📍 Estado do município determinado: ${ufMunicipio} -> ${estadoMunicipio}`);
                                }
                            }
                        }

                        if (estadoMunicipio) {
                            const normalizedEstado = normalize(estadoMunicipio);
                            const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                            representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                            console.log('📍 Buscando por cidade+estado (estado determinado):', cidadeEstadoKey);
                        } else {
                            console.log('⚠️ Não foi possível determinar o estado do município');
                            representatives = [];
                        }
                    }

                    console.log('📍 Chaves disponíveis no map:', Array.from(municipioRepresentativeMap.keys()).slice(0, 10));

                    console.log(`📊 Representantes encontrados inicialmente: ${representatives.length}`);
                    console.log('📋 Representantes:', representatives);

                    // Filtrar representantes que atendem especificamente este município
                    const filteredRepresentatives = representatives.filter(rep => {
                        if (rep.EstadosDetalhados) {
                            // Verificar se o município está em algum dos estados do representante
                            const atendeMunicipio = Object.entries(rep.EstadosDetalhados).some(([estado, dadosEstado]) => {
                                return dadosEstado.cidades && dadosEstado.cidades.some(cidade =>
                                    normalize(cidade) === normalizedName
                                );
                            });

                            if (atendeMunicipio) {
                                console.log(`✅ ${rep.NomeRepresentante} atende ${municipioName}`);
                            }

                            return atendeMunicipio;
                        }
                        return true; // Se não tem EstadosDetalhados, incluir todos
                    });

                    console.log(`🎯 Representantes finais para ${municipioName}: ${filteredRepresentatives.length}`);

                    renderResults(filteredRepresentatives, municipioName);
                    mainTitle.textContent = `Representantes em ${municipioName}`;

                    // Mostrar legenda com os representantes encontrados
                    updateLegend(filteredRepresentatives);

                    document.getElementById('results-container').scrollIntoView({ behavior: 'smooth' });
                }

                // --- LÓGICA E RENDERIZAÇÃO ---

                function normalize(str) {
                    return (str || "")
                        .toString()
                        .normalize("NFD")
                        .replace(/[̀-ͯ]/g, "")
                        .replace(/[^\w\s]/gi, "")
                        .replace(/\s+/g, " ")
                        .trim()
                        .toLowerCase();
                }

                function handleSearch() {
                    const query = searchInput.value.trim();

                    if (!query) {
                        resetView(false);
                        showInitialMessage();
                        hideSuggestions();
                        // Reset input state
                        searchInput.classList.remove('has-results', 'no-results', 'search-loading');
                        return;
                    }

                    // Adicionar estado de loading
                    searchInput.classList.add('search-loading');
                    searchInput.classList.remove('has-results', 'no-results');

                    // Adicionar ao histórico apenas se não foi uma busca de sugestão
                    if (document.activeElement !== searchInput || !suggestionsContainer.classList.contains('hidden')) {
                        addToRecentSearches(query);
                    }
                    
                    hideSuggestions();

                    // Simular delay para mostrar loading (pode ser removido em produção)
                    setTimeout(() => {
                        const results = searchRepresentatives(query);
                        
                        // Remover loading e adicionar estado baseado nos resultados
                        searchInput.classList.remove('search-loading');
                        
                        if (results.length === 0) {
                            searchInput.classList.add('no-results');
                            renderResults([], query);
                        } else {
                            searchInput.classList.add('has-results');
                            renderResults(results, query);
                        }
                    }, 200); // Delay de 200ms para mostrar loading
                }

                function filterByState(stateCode) {
                    // Não mostrar cards de representantes ao clicar no estado
                    // Apenas mostrar os municípios coloridos
                    showInitialMessage();
                    mainTitle.textContent = `Municípios de ${stateCode} - Clique em um município para ver os representantes`;
                    backButton.classList.remove('hidden');
                    viewMode = 'municipios';
                }

                function renderResults(results, location = null) {
                    console.log(`🎨 Renderizando ${results.length} resultados para: ${location}`);
                    console.log('📋 Resultados:', results);

                    if (!results.length) {
                        console.log('❌ Nenhum resultado para renderizar');
                        resultsContainer.innerHTML = `<div class="text-center text-gray-500 py-8">Nenhum representante encontrado${location ? ' para "' + location + '"' : ''}.</div>`;
                        return;
                    }

                    resultsContainer.innerHTML = results.map((item, index) => {
                        // Preparar informações dos estados
                        let estadosInfo = '';
                        if (item.EstadosDetalhados) {
                            const estadosArray = Object.entries(item.EstadosDetalhados).map(([estado, dados]) => {
                                const cidadesCount = dados.cidades ? dados.cidades.length : 0;
                                return `${estado} (${cidadesCount} cidades)`;
                            });
                            estadosInfo = estadosArray.join(', ');
                        } else {
                            estadosInfo = `${item.Estado} (${item.SiglaEstado})`;
                        }

                        // Separar telefones quando há mais de um
                        let telefonesHtml = '';
                        if (item.celular) {
                            const telefones = item.celular.split(/[\/\s]+/).filter(tel => tel.trim() && tel.trim() !== 'nan');
                            if (telefones.length > 0) {
                                if (telefones.length === 1) {
                                    // Um telefone: layout inline simples
                                    telefonesHtml = `<a href="tel:${telefones[0].trim()}" class="text-blue-600 underline" onclick="event.stopPropagation()">${telefones[0].trim()}</a>`;
                                } else if (telefones.length <= 3) {
                                    // 2-3 telefones: layout inline com separador
                                    telefonesHtml = `<div class="flex flex-wrap gap-1 items-center">
                                        ${telefones.map(tel => 
                                            `<a href="tel:${tel.trim()}" class="phone-pill" onclick="event.stopPropagation()">${tel.trim()}</a>`
                                        ).join('')}
                                    </div>`;
                                } else {
                                    // Muitos telefones: layout compacto com expansão
                                    const primeiros = telefones.slice(0, 2);
                                    const restantes = telefones.slice(2);
                                    telefonesHtml = `<div class="flex flex-wrap gap-1 items-center">
                                        ${primeiros.map(tel => 
                                            `<a href="tel:${tel.trim()}" class="phone-pill" onclick="event.stopPropagation()">${tel.trim()}</a>`
                                        ).join('')}
                                        <button class="phone-expand-btn text-xs px-2 py-1 rounded-full" 
                                                onclick="event.stopPropagation(); this.style.display='none'; this.nextElementSibling.style.display='flex';" 
                                                title="Ver mais ${restantes.length} telefones">
                                            +${restantes.length}
                                        </button>
                                        <div class="hidden flex-wrap gap-1 items-center">
                                            ${restantes.map(tel => 
                                                `<a href="tel:${tel.trim()}" class="phone-pill" onclick="event.stopPropagation()">${tel.trim()}</a>`
                                            ).join('')}
                                        </div>
                                    </div>`;
                                }
                            }
                        }

                        return `
                <div class="result-item bg-blue-50 rounded-lg p-4 shadow-sm cursor-pointer hover:bg-blue-100 transition-colors" 
                     data-representante-index="${index}" 
                     onclick="highlightRepresentanteAreas(${index})">
                    <div class="font-semibold text-blue-800 text-lg mb-2">${item.NomeRepresentante}</div>
                    ${item.CodigoRepresentante ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="id-card-lanyard" class="w-4 h-4"></i> ${item.CodigoRepresentante}</div>` : ''}
                    ${item.Contato ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="user" class="w-4 h-4"></i> ${item.Contato}</div>` : ''}
                    ${item.email ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="mail" class="w-4 h-4"></i> <a href="mailto:${item.email}" class="text-blue-600 underline" onclick="event.stopPropagation()">${item.email}</a></div>` : ''}
                    ${telefonesHtml ? `<div class="text-gray-700 text-sm mb-1"><div class="flex items-start gap-2"><i data-lucide="phone" class="w-4 h-4 mt-0.5 flex-shrink-0"></i> <div class="flex-1">${telefonesHtml}</div></div></div>` : ''}
                </div>
            `;
                    }).join('');

                    // Armazenar resultados globalmente para acesso nas funções de highlight
                    window.currentResults = results;

                    // Inicializar ícones da Lucide após renderizar o conteúdo
                    setTimeout(() => {
                        if (window.lucide) {
                            window.lucide.createIcons();
                        }
                    }, 100);
                }

                function showInitialMessage() {
                    resultsContainer.innerHTML = '<div class="text-center text-gray-500 py-8">Digite uma cidade ou estado para encontrar representantes, ou clique no mapa.</div>';
                }

                // Função para alternar entre modo normal e maximizado do mapa
                function toggleMapMaximize() {
                    const container = document.getElementById('representantes-container');
                    const maximizeBtn = document.getElementById('maximize-map-btn');
                    const isMaximized = container.classList.contains('map-maximized');

                    if (isMaximized) {
                        // Restaurar modo normal
                        container.classList.remove('map-maximized');
                        document.body.classList.remove('map-fullscreen');
                        maximizeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                        </svg>
                    `;
                        maximizeBtn.title = 'Maximizar mapa';
                    } else {
                        // Maximizar mapa em tela cheia
                        container.classList.add('map-maximized');
                        document.body.classList.add('map-fullscreen');
                        maximizeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    `;
                        maximizeBtn.title = 'Restaurar mapa';
                    }

                    // Forçar redimensionamento do mapa
                    setTimeout(() => {
                        if (map) {
                            map.invalidateSize();
                        }
                    }, 100);
                }

                // Função para adicionar label com nome do município
                function addMunicipioLabel(layer, municipioName) {
                    // Função desabilitada - labels removidos conforme solicitado
                    return;

                    // Obter o centro do município
                    const bounds = layer.getBounds();
                    const center = bounds.getCenter();

                    // Criar um div personalizado para o label fixo
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'municipio-label-fixo';
                    labelDiv.innerHTML = municipioName;
                    labelDiv.style.cssText = `
                    position: absolute;
                    background: transparent;
                    border: none;
                    border-radius: 0;
                    padding: 0;
                    font-size: 5px;
                    font-weight: 600;
                    color: #333;
                    text-align: center;
                    white-space: nowrap;
                    pointer-events: none;
                    z-index: 1000;
                    box-shadow: none;
                    transform: translate(-50%, -50%);
                `;

                    // Criar um elemento Leaflet para o label
                    const labelElement = L.divIcon({
                        html: labelDiv,
                        className: 'municipio-label-container',
                        iconSize: [1, 1],
                        iconAnchor: [0, 0]
                    });

                    // Criar um marcador para o label
                    const labelMarker = L.marker(center, {
                        icon: labelElement,
                        interactive: false
                    }).addTo(map);

                    // Armazenar referência para poder remover depois se necessário
                    if (!window.municipioLabels) {
                        window.municipioLabels = [];
                    }
                    window.municipioLabels.push(labelMarker);
                }



                // Função para destacar áreas atendidas por um representante
                function highlightRepresentanteAreas(index) {
                    if (!window.currentResults || !window.currentResults[index]) {
                        console.log('Representante não encontrado no índice:', index);
                        return;
                    }

                    const representante = window.currentResults[index];
                    console.log('Destacando áreas do representante:', representante.NomeRepresentante);

                    // Remover highlight anterior se existir
                    if (highlightedMunicipiosLayer) {
                        map.removeLayer(highlightedMunicipiosLayer);
                        highlightedMunicipiosLayer = null;
                    }

                    // Encontrar municípios atendidos pelo representante
                    const municipiosDestacados = [];

                    if (representante.EstadosDetalhados) {
                        // Nova estrutura: percorrer estados e suas cidades
                        Object.entries(representante.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                            // FILTRO: Se estivermos visualizando um estado específico, mostrar apenas municípios deste estado
                            if (viewMode === 'municipios' && currentState && currentState.code && 
                                estado !== currentState.code && normalize(estado) !== normalize(currentState.code)) {
                                return; // Pular este estado se não for o estado atual
                            }

                            if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                dadosEstado.cidades.forEach(cidade => {
                                    const normalizedCidade = normalize(cidade);

                                    // IMPORTANTE: Buscar município considerando o estado para evitar conflitos
                                    const municipioFeature = municipiosData.features.find(feature => {
                                        const props = feature.properties;
                                        const municipioName = props.name || props.nome || props.municipio || props.description;
                                        const municipioState = props.uf || props.estado || props.sigla_uf || props.UF || props.ESTADO || props.cd_geocuf;

                                        // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                                        let extractedState = municipioState;
                                        if (!extractedState && props.uf_municipio) {
                                            const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                                            if (match) {
                                                extractedState = match[1];
                                            }
                                        }

                                        // Verificar se o município e estado correspondem
                                        return normalize(municipioName) === normalizedCidade &&
                                            (extractedState === estado || normalize(extractedState) === normalize(estado));
                                    });

                                    if (municipioFeature) {
                                        municipiosDestacados.push(municipioFeature);
                                    }
                                });
                            }
                        });
                    } else {
                        // Estrutura antiga: usar CidadesAtendidas
                        // FILTRO: Se estivermos visualizando um estado específico, mostrar apenas municípios deste estado
                        if (viewMode === 'municipios' && currentState && currentState.code && 
                            representante.SiglaEstado !== currentState.code && 
                            normalize(representante.SiglaEstado) !== normalize(currentState.code)) {
                            // Não destacar municípios de outros estados quando estiver focado em um estado específico
                            console.log(`Pulando representante ${representante.NomeRepresentante} do estado ${representante.SiglaEstado} pois estamos focados no estado ${currentState.code}`);
                        } else {
                            const cidadesAtendidas = representante.CidadesAtendidas || [];
                            cidadesAtendidas.forEach(cidade => {
                                const normalizedCidade = normalize(cidade);

                                // IMPORTANTE: Buscar município considerando o estado para evitar conflitos
                                const municipioFeature = municipiosData.features.find(feature => {
                                    const props = feature.properties;
                                    const municipioName = props.name || props.nome || props.municipio || props.description;
                                    const municipioState = props.uf || props.estado || props.sigla_uf || props.UF || props.ESTADO || props.cd_geocuf;

                                    // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                                    let extractedState = municipioState;
                                    if (!extractedState && props.uf_municipio) {
                                        const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                                        if (match) {
                                            extractedState = match[1];
                                        }
                                    }

                                    // Verificar se o município e estado correspondem
                                    return normalize(municipioName) === normalizedCidade &&
                                        (extractedState === representante.SiglaEstado || normalize(extractedState) === normalize(representante.SiglaEstado));
                                });

                                if (municipioFeature) {
                                    municipiosDestacados.push(municipioFeature);
                                }
                            });
                        }
                    }

                    if (municipiosDestacados.length === 0) {
                        console.log('Nenhum município encontrado no mapa para o representante:', representante.NomeRepresentante);
                        alert(`Nenhum município encontrado no mapa para ${representante.NomeRepresentante}`);
                        return;
                    }

                    console.log(`Encontrados ${municipiosDestacados.length} municípios para destacar`);

                    // Criar camada de destaque
                    const representanteColor = representativeColorMap.get(representante.id) || '#FF6B6B';

                    highlightedMunicipiosLayer = L.geoJson(municipiosDestacados, {
                        style: {
                            fillColor: representanteColor,
                            weight: 3,
                            opacity: 1,
                            color: '#FFFFFF',
                            dashArray: '5,5',
                            fillOpacity: 0.8
                        },
                        onEachFeature: function (feature, layer) {
                            const props = feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;

                            layer.bindTooltip(`
                            <strong>${municipioName}</strong><br>
                            <span style="color: ${representanteColor}; font-weight: bold;">●</span> ${representante.NomeRepresentante}
                        `, {
                                permanent: false,
                                direction: 'top',
                                className: 'highlight-tooltip'
                            });
                        }
                    }).addTo(map);

                    // Fazer zoom para mostrar todos os municípios destacados
                    if (highlightedMunicipiosLayer.getBounds().isValid()) {
                        map.fitBounds(highlightedMunicipiosLayer.getBounds(), {
                            padding: [20, 20],
                            maxZoom: 8
                        });
                    }

                    // Destacar o card clicado
                    document.querySelectorAll('.result-item').forEach((card, i) => {
                        if (i === index) {
                            card.style.backgroundColor = representanteColor + '20'; // 20% opacity
                            card.style.borderLeft = `4px solid ${representanteColor}`;
                        } else {
                            card.style.backgroundColor = '';
                            card.style.borderLeft = '';
                        }
                    });

                    // Atualizar título
                    mainTitle.textContent = `Áreas atendidas por ${representante.NomeRepresentante} (${municipiosDestacados.length} municípios)`;
                }

                function resetView(clearSearch = true) {
                    // Reset de todas as seleções
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                        selectedStateLayer = null;
                    }

                    if (selectedMunicipioLayer) {
                        selectedMunicipioLayer = null;
                    }

                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    if (highlightedMunicipiosLayer) {
                        map.removeLayer(highlightedMunicipiosLayer);
                        highlightedMunicipiosLayer = null;
                    }

                    // Remover bairros quando voltar para visualização geral
                    if (bairrosLayer && map.hasLayer(bairrosLayer)) {
                        map.removeLayer(bairrosLayer);
                        console.log('🏘️ Bairros removidos ao voltar para visualização geral');
                    }



                    currentState = null;
                    viewMode = 'states';

                    map.setView([-15.78, -47.92], 4);
                    if (clearSearch) searchInput.value = '';
                    showInitialMessage();
                    backButton.classList.add('hidden');
                    mainTitle.textContent = 'Escolha sua região para encontrar representantes';

                    // Atualizar estilos dos municípios se ainda estiverem visíveis
                    if (municipiosLayer) {
                        municipiosLayer.eachLayer(layer => {
                            const props = layer.feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            layer.setStyle(getMunicipioStyleByRepresentative(municipioName));
                        });
                    }

                    // Esconder legenda
                    updateLegend([]);

                    // Remove legenda de cores se existir
                    const existingLegend = document.getElementById('color-legend');
                    if (existingLegend) {
                        existingLegend.remove();
                    }

                    // Reset dos cards destacados
                    document.querySelectorAll('.result-item').forEach(card => {
                        card.style.backgroundColor = '';
                        card.style.borderLeft = '';
                    });
                }

                initializeApp();
            });
        </script>
</body>

</html>