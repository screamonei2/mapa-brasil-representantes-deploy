<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encontre Nossos Representantes</title>

    <!-- Depend√™ncias do Mapa (Leaflet.js) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Estiliza√ß√£o com Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <style>
        /* Remover todos os outlines de focus */
        * {
            outline: none !important;
        }

        /* Remover focus espec√≠fico de bot√µes e inputs */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        body,
        html {
            height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            overflow-x: hidden;
        }

        #representantes-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .grid-container {
            flex: 1;
            display: grid;
            gap: 1rem;
            grid-template-columns: 1fr;
            min-height: 0;
        }

        @media (min-width: 1024px) {
            .grid-container {
                grid-template-columns: 3fr 2fr;
                gap: 2rem;
            }
        }

        .map-container {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .map-wrapper {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            padding: 1rem;
            position: relative;
            min-height: 300px;
        }

        #map {
            height: 100%;
            width: 100%;
            border-radius: 0.5rem;
            background-color: #fff;
            min-height: 300px;
        }

        @media (min-width: 768px) {
            #map {
                min-height: 400px;
            }
        }

        @media (min-width: 1024px) {
            #map {
                min-height: calc(100vh - 200px);
            }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .sidebar-content {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
            max-height: 400px;
        }

        @media (min-width: 1024px) {
            .results-container {
                max-height: calc(100vh - 300px);
            }
        }

        @media (max-height: 600px) {
            .results-container {
                max-height: 250px;
            }

            #map {
                min-height: 250px;
            }
        }

        /* Melhorias para dispositivos m√≥veis muito pequenos */
        @media (max-width: 480px) {
            #representantes-container {
                padding: 0.5rem;
            }

            .main-content {
                gap: 0.5rem;
            }

            .map-wrapper {
                padding: 0.5rem;
            }

            .sidebar-content {
                padding: 1rem;
            }

            .results-container {
                max-height: 300px;
            }
        }

        @media (max-width: 480px) and (max-height: 700px) {
            #map {
                min-height: 200px;
            }

            .results-container {
                max-height: 200px;
            }
        }

        /* Ajustes para orienta√ß√£o landscape em dispositivos m√≥veis */
        @media (max-height: 500px) and (orientation: landscape) {
            .grid-container {
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }

            #map {
                min-height: 200px;
            }

            .results-container {
                max-height: 200px;
            }

            #representantes-container {
                padding: 0.5rem;
            }
        }

        .leaflet-interactive {
            transition: fill-opacity 0.2s ease-in-out;
        }

        .result-item {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* .municipio-tooltip {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
        } */

        /* Bot√£o de Reset Zoom */
        .reset-zoom-btn {
            position: absolute;
            bottom: 10px;
            right: 50px;
            z-index: 1000;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reset-zoom-btn:hover {
            background: #f4f4f4;
            border-color: rgba(0, 0, 0, 0.4);
        }

        .reset-zoom-btn svg {
            width: 18px;
            height: 18px;
            color: #333;
        }

        /* Bot√£o de Maximizar Mapa */
        .maximize-map-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .maximize-map-btn:hover {
            background: #f4f4f4;
            border-color: rgba(0, 0, 0, 0.4);
        }

        .maximize-map-btn svg {
            width: 18px;
            height: 18px;
            color: #333;
        }

        /* Estado maximizado */
        .map-maximized .grid-container {
            grid-template-columns: 1fr !important;
        }

        .map-maximized .sidebar {
            display: none !important;
        }

        .map-maximized .map-container {
            grid-column: 1 / -1;
        }

        .map-maximized .map-wrapper {
            min-height: calc(100vh - 100px) !important;
        }

        /* Modo tela cheia real */
        .map-fullscreen {
            overflow: hidden !important;
        }

        .map-fullscreen #representantes-container {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            background: white !important;
            padding: 0 !important;
            margin: 0 !important;
            max-width: none !important;
        }

        .map-fullscreen .map-wrapper {
            height: 100vh !important;
            min-height: 100vh !important;
            border-radius: 0 !important;
            padding: 0 !important;
        }

        .map-fullscreen #map {
            height: 100vh !important;
            min-height: 100vh !important;
            border-radius: 0 !important;
        }

        .map-fullscreen .maximize-map-btn {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 10000 !important;
        }

        /* Labels dos munic√≠pios - Fixos e sempre vis√≠veis */
        /* CSS das labels comentado pois as labels foram removidas
        .municipio-label-fixo {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            font-size: 5px !important;
            font-weight: 600 !important;
            color: #333 !important;
            text-align: center !important;
            white-space: nowrap !important;
            box-shadow: none !important;
            pointer-events: none !important;
            z-index: 1000 !important;
            font-family: 'Inter', sans-serif !important;
            line-height: 1.2 !important;
            max-width: 120px !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            text-shadow: 
                -1px -1px 0 #ffffff,
                1px -1px 0 #ffffff,
                -1px 1px 0 #ffffff,
                1px 1px 0 #ffffff;
        }
        
        .municipio-label-container {
            background: transparent !important;
            border: none !important;
        }

        /* Ajustar tamanho do texto baseado no zoom */
        .leaflet-zoom-animated .municipio-label-fixo {
            font-size: 7px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-6 .municipio-label-fixo,
        .leaflet-zoom-animated.leaflet-zoom-level-7 .municipio-label-fixo {
            font-size: 8px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-8 .municipio-label-fixo,
        .leaflet-zoom-animated.leaflet-zoom-level-9 .municipio-label-fixo {
            font-size: 9px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-10 .municipio-label-fixo {
            font-size: 10px !important;
        }

        */

        /* Estilos para busca melhorada */
        .search-filter.active {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: #ffffff;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4), 0 2px 4px rgba(37, 99, 235, 0.3);
            font-weight: 500;
        }

        .search-filter.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: inherit;
            pointer-events: none;
        }

        .search-filter.active i,
        .search-filter.active span {
            position: relative;
            z-index: 1;
            color: #ffffff !important;
        }

        .search-filter {
            background-color: #f8fafc;
            color: #64748b;
            border-color: #e2e8f0;
            font-weight: 400;
        }

        .search-filter:hover:not(.active) {
            background-color: #f1f5f9;
            border-color: #cbd5e1;
            color: #475569;
        }

        .search-filter:hover:not(.active) i {
            color: #475569 !important;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .suggestion-item:hover, .suggestion-item.highlighted {
            background-color: #f3f4f6;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-type {
            font-size: 10px;
            background-color: #e5e7eb;
            color: #6b7280;
            padding: 2px 6px;
            border-radius: 10px;
            text-transform: uppercase;
            font-weight: 500;
            margin-left: 8px;
        }

        .recent-search-item {
            background-color: #f3f4f6;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recent-search-item:hover {
            background-color: #e5e7eb;
            color: #374151;
        }

        #clear-search {
            transition: all 0.2s;
        }

        /* Anima√ß√µes e transi√ß√µes melhoradas */
        #suggestions-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.2s ease-out;
        }

        #suggestions-container:not(.hidden) {
            opacity: 1;
            transform: translateY(0);
        }

        .search-filter {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: scale(1);
            position: relative;
            overflow: hidden;
        }

        .search-filter:hover {
            transform: scale(1.02) translateY(-1px);
        }

        .search-filter.active {
            transform: scale(1.02) translateY(-1px);
        }

        .search-filter:active {
            transform: scale(0.98) translateY(0px);
        }

        .recent-search-item {
            transition: all 0.2s ease-out;
            transform: scale(1);
        }

        .recent-search-item:hover {
            transform: scale(1.05);
        }

        /* Indicador de loading no input */
        .search-loading::after {
            content: '';
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border: 2px solid #f3f4f6;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }

        /* Estados do input */
        #search-input:focus {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        #search-input.has-results {
            border-color: #10b981;
        }

        #search-input.no-results {
            border-color: #ef4444;
        }

        #search-input.has-suggestions {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        #search-input.has-suggestions::placeholder {
            color: #3b82f6;
            opacity: 0.7;
        }

        /* Estilos para telefones nos cards */
        .phone-pill {
            display: inline-flex;
            align-items: center;
            background-color: #eff6ff;
            color: #2563eb;
            padding: 4px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            text-decoration: none;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .phone-pill:hover {
            background-color: #dbeafe;
            border-color: #93c5fd;
            text-decoration: none;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
        }

        .phone-expand-btn {
            background-color: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
            transition: all 0.2s ease;
        }

        .phone-expand-btn:hover {
            background-color: #e5e7eb;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        /* Estilos para bairros de S√£o Paulo */
        .bairro-with-rep {
            /* filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.8)) 
                    drop-shadow(0 0 6px rgba(255, 255, 255, 0.6)); */
        }

        .bairro-without-rep {
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.7)) 
                    drop-shadow(0 0 4px rgba(255, 255, 255, 0.5));
        }

        /* Alternativa usando outline para SVG paths */
        .leaflet-interactive.bairro-with-rep {
            stroke-dasharray: 1,10 !important;
            stroke: #ffffff !important;
            stroke-width: 3px !important;
            /* filter: drop-shadow(0 0 10px white); */
        }

        .leaflet-interactive.bairro-without-rep {
            stroke-dasharray: 6,4 !important;
            stroke: #DC2626 !important;
            stroke-width: 2 !important;
            opacity: 0.6 !important;
            filter: drop-shadow(0 0 2px white);
        }
    </style>

</head>

<body class="bg-gray-50">

    <div id="representantes-container" class="container mx-auto p-2 sm:p-4 lg:p-6 max-w-7xl">

        <div class="mb-4 lg:mb-6">
            <h1 id="main-title" class="text-xl sm:text-2xl lg:text-3xl font-bold text-gray-800">Escolha sua regi√£o para
                encontrar
                representantes</h1>
            <button id="back-to-brazil" class="hidden text-blue-600 font-semibold mt-2 hover:underline">&lt; VOLTAR PARA
                O MAPA DO BRASIL</button>
        </div>

        <div class="main-content">
            <div class="grid-container">

                <!-- Coluna do Mapa -->
                <div class="map-container">
                    <div class="map-wrapper">
                        <div id="map"></div>
                        <button id="reset-zoom-btn" class="reset-zoom-btn" title="Resetar zoom">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" />
                            </svg>
                        </button>

                        <button id="maximize-map-btn" class="maximize-map-btn" title="Maximizar mapa">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Coluna de Busca e Resultados -->
                <div class="sidebar">
                    <div class="sidebar-content">
                        <h2 class="text-lg sm:text-xl font-bold text-gray-800 mb-4">SEUS REPRESENTANTES</h2>

                        <div class="mb-4 relative">
                            <!-- Campo de busca principal -->
                            <div class="relative">
                                <input type="text" id="search-input" placeholder="Ex: S√£o Paulo, SCHIOPPA em SP, Santos..."
                                    class="w-full px-10 py-2 sm:px-12 sm:py-3 border border-gray-300 rounded-lg outline-none transition text-sm sm:text-base focus:border-blue-500 focus:ring-2 focus:ring-blue-200"
                                    autocomplete="off">
                                <!-- √çcone de busca -->
                                <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400"></i>
                                
                                <!-- Bot√£o para limpar busca -->
                                <button id="clear-search" class="absolute right-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 hover:text-gray-600 hidden">
                                    <i data-lucide="x" class="h-4 w-4"></i>
                                </button>
                            </div>
                            
                            <!-- Dropdown de sugest√µes -->
                            <div id="suggestions-container" class="absolute top-full left-0 right-0 z-50 bg-white border border-gray-200 rounded-lg shadow-lg mt-1 max-h-64 overflow-y-auto hidden">
                                <div id="suggestions-list"></div>
                            </div>
                            
                            <!-- Filtros r√°pidos -->
                            <div class="flex flex-wrap gap-2 mt-3">
                                <button class="search-filter active px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="all">
                                    <i data-lucide="globe" class="h-3 w-3"></i>
                                    Todos
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="estados">
                                    <i data-lucide="map" class="h-3 w-3"></i>
                                    Estados
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="cidades">
                                    <i data-lucide="map-pin" class="h-3 w-3"></i>
                                    Cidades
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="bairros">
                                    <i data-lucide="home" class="h-3 w-3"></i>
                                    Bairros (SP)
                                </button>
                                <button class="search-filter px-3 py-1 text-xs rounded-full border transition flex items-center gap-1" data-filter="representantes">
                                    <i data-lucide="users" class="h-3 w-3"></i>
                                    Representantes
                                </button>
                            </div>
                            
                            <!-- Hist√≥rico de buscas recentes -->
                            <div id="recent-searches" class="mt-3 hidden">
                                <h4 class="text-xs font-medium text-gray-600 mb-2 flex items-center gap-1">
                                    <i data-lucide="clock" class="h-3 w-3"></i>
                                    Buscas recentes:
                                </h4>
                                <div id="recent-searches-list" class="flex flex-wrap gap-1"></div>
                            </div>
                        </div>

                        <div id="results-container" class="results-container space-y-3 pr-2">
                            <div id="initial-message" class="text-center py-16">
                                <div id="loading-indicator">
                                    <svg class="animate-spin mx-auto h-12 w-12 text-blue-600"
                                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                            stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor"
                                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                        </path>
                                    </svg>
                                    <p class="mt-4 text-sm text-gray-500">Carregando dados...</p>
                                </div>
                                <div id="default-message" class="hidden">
                                    <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg"
                                        fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round"
                                            d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m5.231 13.481L15 17.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Zm3.75 11.625a2.625 2.625 0 1 1-5.25 0 2.625 2.625 0 0 1 5.25 0Z" />
                                    </svg>
                                    <p class="mt-4 text-sm text-gray-500">Use a busca ou clique em um estado no mapa.
                                    </p>
                                </div>
                            </div>

                            <!-- Legenda de Representantes -->
                            <div id="legend" class="legend hidden mt-4 p-3 bg-white rounded-lg border border-gray-200">
                                <h3 class="text-sm font-semibold text-gray-700 mb-2">Legenda de Cores</h3>
                                <div id="legend-items" class="space-y-1 max-h-32 overflow-y-auto"></div>
                                <div class="mt-2 pt-2 border-t border-gray-200">
                                    <div class="flex items-center text-xs text-gray-600">
                                        <div class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                                        <span>Sem representante</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            document.addEventListener('DOMContentLoaded', async function () {
                // --- CONFIGURA√á√ÉO ---
                const jsonFileUrl = './data/representantes_por_estado.json';
                const municipiosJsonUrl = 'https://raw.githubusercontent.com/screamonei2/mapa-brasil-representantes/main/old/geojs-100-mun-v2.json';

                // URL do GeoJSON dos estados do Brasil
                const brazilStatesGeoJsonUrl = './data/uf.json';

                // URL do GeoJSON dos bairros de S√£o Paulo
                const bairrosGeoJsonUrl = './data/bairros.geojson';

                // --- VARI√ÅVEIS GLOBAIS ---
                let representativesData = [];
                let representativesByLocation = new Map();
                let municipiosData = [];
                let map;
                let geoJsonLayer;
                let municipiosLayer = null;
                let bairrosLayer = null;
                let selectedStateLayer = null;
                let selectedMunicipioLayer = null;
                let currentState = null;
                let viewMode = 'states'; // 'states' ou 'municipios'
                let municipioRepresentativeMap = new Map(); // Mapa munic√≠pio -> representantes
                let representativeColorMap = new Map(); // Mapa representante -> cor
                let highlightedMunicipiosLayer = null; // Camada para destacar munic√≠pios do representante

                // Paleta de cores para representantes (azul padr√£o como primeira cor para SCHIOPPA)
                const representativeColors = ['#206ce7', '#3c27f5', '#a831ff', '#ed57e4', '#f762a6', '#ff0e09', '#e98e32', '#f6f23a', '#aaff46', '#72ef6a', '#13f472', '#1dffe8', '#45aceb', '#4e66f6', '#925aff', '#c420e7', '#f527b7', '#ff315f', '#ed7e57', '#f7d062', '#c8ff09', '#69e932', '#3af65c', '#46ffc0', '#6adcef', '#1369f4', '#341dff', '#a545eb', '#f64eec', '#ff5aa6', '#e72420', '#f58e27', '#fffa31', '#a8ed57', '#6af762', '#09ff70', '#32e9d7', '#3aaef6', '#4660ff', '#976aef', '#cb13f4', '#ff1dbb', '#eb4569', '#f67a4e', '#ffd45a', '#bbe720', '#65f527']
                    ;

                // Mapa espec√≠fico de cores para representantes especiais
                // COMENTADO: N√£o √© mais necess√°rio, cores est√£o em representativeColors
                // const specialRepresentativeColors = {
                //     'schioppa': '#3b82f6',  // Azul padr√£o para SCHIOPPA
                //     'rg representacoes ltda': '#dc2626',  // Vermelho para RG REPRESENTA√á√ïES (c√≥digo 42)
                //     '3l representacoes comerciais ltda me': '#FF0000'  // Vermelho para 3L REPRESENTA√á√ïES
                // };

                const searchInput = document.getElementById('search-input');
                const resultsContainer = document.getElementById('results-container');
                const initialMessage = document.getElementById('initial-message');
                const loadingIndicator = document.getElementById('loading-indicator');
                const defaultMessage = document.getElementById('default-message');
                const backButton = document.getElementById('back-to-brazil');
                const mainTitle = document.getElementById('main-title');
                
                // Novos elementos para busca melhorada
                const clearSearchButton = document.getElementById('clear-search');
                const suggestionsContainer = document.getElementById('suggestions-container');
                const suggestionsList = document.getElementById('suggestions-list');
                const recentSearches = document.getElementById('recent-searches');
                const recentSearchesList = document.getElementById('recent-searches-list');
                const searchFilters = document.querySelectorAll('.search-filter');
                
                // Vari√°veis para controle da busca
                let currentSearchFilter = 'all';
                let searchSuggestions = [];
                let selectedSuggestionIndex = -1;
                let recentSearchesData = JSON.parse(localStorage.getItem('recentSearches') || '[]');

                // --- FUN√á√ïES DE TRANSFORMA√á√ÉO DE DADOS ---

                function transformRepresentativesData(rawData) {
                    console.log('üîÑ Transformando dados dos representantes...');
                    const representativesMap = new Map();
                    const locationMap = new Map();
                    let colorIndex = 0;

                    const stateToAbbrev = {
                        'SAO PAULO': 'SP', 'RIO DE JANEIRO': 'RJ', 'MINAS GERAIS': 'MG', 'BAHIA': 'BA',
                        'PARANA': 'PR', 'RIO GRANDE DO SUL': 'RS', 'PERNAMBUCO': 'PE', 'CEARA': 'CE',
                        'PARA': 'PA', 'SANTA CATARINA': 'SC', 'GOIAS': 'GO', 'MARANHAO': 'MA',
                        'PARAIBA': 'PB', 'AMAZONAS': 'AM', 'ESPIRITO SANTO': 'ES', 'MATO GROSSO': 'MT',
                        'ALAGOAS': 'AL', 'PIAUI': 'PI', 'DISTRITO FEDERAL': 'DF', 'MATO GROSSO DO SUL': 'MS',
                        'SERGIPE': 'SE', 'RIO GRANDE DO NORTE': 'RN', 'RONDONIA': 'RO', 'ACRE': 'AC',
                        'AMAPA': 'AP', 'RORAIMA': 'RR', 'TOCANTINS': 'TO'
                    };

                    // Verificar se os dados est√£o no formato esperado
                    console.log('üìä Estrutura dos dados recebidos:', Object.keys(rawData));

                    // Verificar se existe a propriedade 'representantes'
                    const dadosRepresentantes = rawData.representantes || rawData;

                    for (const [nomeEmpresa, dadosEmpresa] of Object.entries(dadosRepresentantes)) {
                        // Nova estrutura: dadosEmpresa.estados √© um objeto com estados como chaves
                        const codigo = dadosEmpresa.codigo || Math.random().toString();
                        const nome = dadosEmpresa.nome || nomeEmpresa;
                        const contato = dadosEmpresa.contato || {};

                        // Nova estrutura: estados √© um objeto, n√£o um array
                        const estados = dadosEmpresa.estados || {};

                        // Coletar todas as cidades de todos os estados
                        const todasCidades = [];
                        const todosEstados = [];

                        for (const [estado, dadosEstado] of Object.entries(estados)) {
                            todosEstados.push(estado);
                            if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                todasCidades.push(...dadosEstado.cidades);
                            }
                        }

                        // Determinar estado principal (primeiro estado ou 'DESCONHECIDO')
                        const estadoPrincipal = todosEstados.length > 0 ? todosEstados[0].trim() : 'DESCONHECIDO';
                        const siglaEstado = stateToAbbrev[estadoPrincipal] || estadoPrincipal.substring(0, 2);

                        const representante = {
                            id: `${nomeEmpresa}_${codigo}`,
                            NomeRepresentante: nome,
                            Contato: contato.nome_contato || '',
                            email: contato.email || '',
                            celular: contato.celular || '',
                            SiglaEstado: siglaEstado,
                            Estado: estadoPrincipal,
                            CidadesAtendidas: todasCidades,
                            CodigoRepresentante: codigo,
                            // Adicionar dados dos estados para uso posterior
                            EstadosDetalhados: estados
                        };

                        representativesMap.set(representante.id, representante);

                        // Atribuir cor ao representante
                        if (!representativeColorMap.has(representante.id)) {
                            // COMENTADO: L√≥gica de cores especiais removida, usar apenas cores gerais
                            // Verificar se √© um representante especial com cor espec√≠fica
                            // const nomeNormalizado = nomeEmpresa.toLowerCase();
                            // console.log(`üé® Verificando cor para: ${nomeNormalizado} (${nomeEmpresa})`);
                            
                            // if (specialRepresentativeColors[nomeNormalizado]) {
                            //     representativeColorMap.set(representante.id, specialRepresentativeColors[nomeNormalizado]);
                            //     console.log(`‚úÖ Cor especial atribu√≠da: ${representante.NomeRepresentante} -> ${specialRepresentativeColors[nomeNormalizado]}`);
                            // } else {
                                representativeColorMap.set(representante.id, representativeColors[colorIndex % representativeColors.length]);
                                // console.log(`üé® Cor padr√£o atribu√≠da: ${representante.NomeRepresentante} -> ${representativeColors[colorIndex % representativeColors.length]}`);
                                colorIndex++;
                            // }
                        }

                        // Indexar por estado
                        todosEstados.forEach(estado => {
                            const sigla = stateToAbbrev[estado] || estado.substring(0, 2);
                            [estado, sigla].forEach(key => {
                                if (!locationMap.has(key)) locationMap.set(key, new Set());
                                locationMap.get(key).add(representante.id);
                            });
                        });

                        // Indexar por cada cidade e criar mapeamento munic√≠pio-representante
                        // Nova estrutura: cidade+estado -> representante
                        for (const [estado, dadosEstado] of Object.entries(estados)) {
                            if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                dadosEstado.cidades.forEach(cidade => {
                                    const normalizedCidade = normalize(cidade);
                                    const normalizedEstado = normalize(estado);
                                    const cidadeEstadoKey = `${normalizedCidade}-${normalizedEstado}`;

                                    if (!locationMap.has(cidade)) locationMap.set(cidade, new Set());
                                    locationMap.get(cidade).add(representante.id);

                                    // Mapear munic√≠pio+estado para representante (objeto completo)
                                    if (!municipioRepresentativeMap.has(cidadeEstadoKey)) {
                                        municipioRepresentativeMap.set(cidadeEstadoKey, []);
                                    }
                                    municipioRepresentativeMap.get(cidadeEstadoKey).push(representante);

                                    // IMPORTANTE: N√ÉO mapear apenas por cidade para evitar conflitos entre estados
                                    // Remover esta parte que causava o problema:
                                    // if (!municipioRepresentativeMap.has(normalizedCidade)) {
                                    //     municipioRepresentativeMap.set(normalizedCidade, []);
                                    // }
                                    // municipioRepresentativeMap.get(normalizedCidade).push(representante);
                                });
                            }

                            // Mapear bairros se existirem para o estado SP
                            if (estado === 'SP' && dadosEstado.bairros && Array.isArray(dadosEstado.bairros)) {
                                dadosEstado.bairros.forEach(bairro => {
                                    const normalizedBairro = normalize(bairro);

                                    // Mapear bairro no municipioRepresentativeMap
                                    if (!municipioRepresentativeMap.has(normalizedBairro)) {
                                        municipioRepresentativeMap.set(normalizedBairro, []);
                                    }
                                    municipioRepresentativeMap.get(normalizedBairro).push(representante);

                                    // CORRE√á√ÉO: Tamb√©m mapear bairro no locationMap para busca geral
                                    if (!locationMap.has(bairro)) locationMap.set(bairro, new Set());
                                    locationMap.get(bairro).add(representante.id);
                                    
                                    // Mapear vers√£o normalizada tamb√©m
                                    if (!locationMap.has(normalizedBairro)) locationMap.set(normalizedBairro, new Set());
                                    locationMap.get(normalizedBairro).add(representante.id);

                                    console.log(`üèòÔ∏è Mapeando bairro "${bairro}" para representante "${nome}"`);
                                });
                            }
                        }
                    }

                    representativesByLocation = locationMap;

                    console.log(`‚úÖ Transforma√ß√£o conclu√≠da:`);
                    console.log(`üìä Total de representantes: ${representativesMap.size}`);
                    console.log(`üìä Total de localiza√ß√µes: ${locationMap.size}`);
                    console.log(`üìä Total de mapeamentos munic√≠pio-representante: ${municipioRepresentativeMap.size}`);
                    console.log(`üìã Primeiras 5 chaves do municipioRepresentativeMap:`, Array.from(municipioRepresentativeMap.keys()).slice(0, 5));

                    return Array.from(representativesMap.values());
                }

                // --- FUN√á√ÉO ESPECIAL PARA SCHIOPPA ---

                function mapSchioppaToAllMunicipios() {
                    // Estados que a SCHIOPPA atende
                    const estadosSchioppa = ['SE', 'RR', 'RN', 'AL', 'RO', 'MA', 'AP', 'AC'];

                    // Encontrar o representante SCHIOPPA
                    const schioppaRep = representativesData.find(rep =>
                        rep.NomeRepresentante && rep.NomeRepresentante.toLowerCase().includes('schioppa')
                    );

                    if (!schioppaRep) {
                        console.log('SCHIOPPA n√£o encontrada nos dados');
                        return;
                    }

                    console.log('Mapeando SCHIOPPA para todos os munic√≠pios dos estados:', estadosSchioppa);
                    // COMENTADO: Logs de debug removidos
                    // console.log('SCHIOPPA encontrada:', schioppaRep.NomeRepresentante, 'ID:', schioppaRep.id);
                    // console.log('Cor da SCHIOPPA:', representativeColorMap.get(schioppaRep.id));

                    // Percorrer todos os munic√≠pios e mapear os dos estados da SCHIOPPA
                    if (municipiosData && municipiosData.features) {
                        let municipiosMapeados = 0;

                        municipiosData.features.forEach(feature => {
                            const props = feature.properties;
                            let ufMunicipio = '';

                            // Extrair UF do munic√≠pio (diferentes formatos poss√≠veis)
                            if (props.uf_municipio) {
                                // Formato: "UF - Munic√≠pio"
                                ufMunicipio = props.uf_municipio.split(' - ')[0];
                            } else if (props.uf) {
                                ufMunicipio = props.uf;
                            } else if (props.estado) {
                                ufMunicipio = props.estado;
                            }

                            // Se o munic√≠pio pertence a um estado da SCHIOPPA
                            if (estadosSchioppa.includes(ufMunicipio)) {
                                const nomeMunicipio = props.nome || props.name || props.municipio || '';
                                const normalizedName = normalize(nomeMunicipio);

                                if (normalizedName) {
                                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                                    // N√£o mapear apenas por nome da cidade
                                    const cidadeEstadoKey = `${normalizedName}-${ufMunicipio.toLowerCase()}`;

                                    if (!municipioRepresentativeMap.has(cidadeEstadoKey)) {
                                        municipioRepresentativeMap.set(cidadeEstadoKey, []);
                                    }

                                    // Verificar se SCHIOPPA j√° est√° mapeada para este munic√≠pio+estado
                                    const existingReps = municipioRepresentativeMap.get(cidadeEstadoKey);
                                    const jaExiste = existingReps.some(rep => rep.id === schioppaRep.id);

                                    if (!jaExiste) {
                                        municipioRepresentativeMap.get(cidadeEstadoKey).push(schioppaRep);
                                        municipiosMapeados++;
                                    }

                                    // N√ÉO mapear apenas por cidade para evitar conflitos entre estados
                                    // Remover esta parte que causava o problema:
                                    // if (!municipioRepresentativeMap.has(normalizedName)) {
                                    //     municipioRepresentativeMap.set(normalizedName, []);
                                    // }
                                    // 
                                    // const existingRepsCidade = municipioRepresentativeMap.get(normalizedName);
                                    // const jaExisteCidade = existingRepsCidade.some(rep => rep.id === schioppaRep.id);
                                    // 
                                    // if (!jaExisteCidade) {
                                    //     municipioRepresentativeMap.get(normalizedName).push(schioppaRep);
                                    // }
                                }
                            }
                        });

                        console.log(`SCHIOPPA mapeada para ${municipiosMapeados} munic√≠pios`);
                    } else {
                        console.log('Dados de munic√≠pios n√£o dispon√≠veis para mapeamento da SCHIOPPA');
                    }
                }

                // --- FUN√á√ïES DE BUSCA MELHORADAS ---

                // Fun√ß√£o para calcular similaridade entre strings (Levenshtein distance)
                function calculateSimilarity(str1, str2) {
                    const longer = str1.length > str2.length ? str1 : str2;
                    const shorter = str1.length > str2.length ? str2 : str1;
                    
                    if (longer.length === 0) return 1.0;
                    
                    const distance = levenshteinDistance(longer, shorter);
                    return (longer.length - distance) / longer.length;
                }

                // Implementa√ß√£o do algoritmo de Levenshtein
                function levenshteinDistance(str1, str2) {
                    const matrix = [];
                    
                    for (let i = 0; i <= str2.length; i++) {
                        matrix[i] = [i];
                    }
                    
                    for (let j = 0; j <= str1.length; j++) {
                        matrix[0][j] = j;
                    }
                    
                    for (let i = 1; i <= str2.length; i++) {
                        for (let j = 1; j <= str1.length; j++) {
                            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                                matrix[i][j] = matrix[i - 1][j - 1];
                            } else {
                                matrix[i][j] = Math.min(
                                    matrix[i - 1][j - 1] + 1,
                                    matrix[i][j - 1] + 1,
                                    matrix[i - 1][j] + 1
                                );
                            }
                        }
                    }
                    
                    return matrix[str2.length][str1.length];
                }

                // Fun√ß√£o para determinar o tipo de busca
                function determineSearchType(query) {
                    const normalizedQuery = normalize(query);
                    
                    // 1. Verificar se √© busca por estado (sigla ou nome completo)
                    const statePatterns = [
                        /^(sp|rj|mg|ba|pr|rs|pe|ce|pa|sc|go|ma|pb|am|es|mt|al|pi|df|ms|se|rn|ro|ac|ap|rr|to)$/i,
                        /^(s√£o paulo|rio de janeiro|minas gerais|bahia|paran√°|rio grande do sul|pernambuco|cear√°|par√°|santa catarina|goi√°s|maranh√£o|para√≠ba|amazonas|esp√≠rito santo|mato grosso|alagoas|piau√≠|distrito federal|mato grosso do sul|sergipe|rio grande do norte|rond√¥nia|acre|amap√°|roraima|tocantins)$/i
                    ];
                    
                    for (const pattern of statePatterns) {
                        if (pattern.test(normalizedQuery)) {
                            return { type: 'estado', query: normalizedQuery };
                        }
                    }
                    
                    // 2. Verificar se √© busca por bairro de S√£o Paulo
                    if (normalizedQuery.includes('vila') || 
                        normalizedQuery.includes('jardim') || 
                        normalizedQuery.includes('jd') ||
                        normalizedQuery.includes('centro') ||
                        normalizedQuery.includes('bairro') ||
                        normalizedQuery.includes('distrito') ||
                        normalizedQuery.includes('cid') ||
                        normalizedQuery.includes('parque') ||
                        normalizedQuery.includes('sao') ||
                        normalizedQuery.includes('jose') ||
                        normalizedQuery.includes('ermelino') ||
                        normalizedQuery.includes('itaquera') ||
                        normalizedQuery.includes('tatuape') ||
                        normalizedQuery.includes('penha') ||
                        normalizedQuery.includes('mooca') ||
                        normalizedQuery.includes('bras') ||
                        normalizedQuery.includes('pari') ||
                        normalizedQuery.includes('belem') ||
                        normalizedQuery.includes('agua') ||
                        normalizedQuery.includes('sapopemba') ||
                        normalizedQuery.includes('aracanduva') ||
                        normalizedQuery.includes('cangaiba') ||
                        normalizedQuery.includes('guaiases') ||
                        normalizedQuery.includes('lajeado') ||
                        normalizedQuery.includes('carrao') ||
                        normalizedQuery.includes('formosa') ||
                        normalizedQuery.includes('carmo') ||
                        normalizedQuery.includes('mateus') ||
                        normalizedQuery.includes('rafael') ||
                        normalizedQuery.includes('iguatemi') ||
                        normalizedQuery.includes('bonifacio')) {
                        return { type: 'bairro', query: normalizedQuery };
                    }
                    
                    // 3. Verificar se √© busca por cidade espec√≠fica
                    return { type: 'cidade', query: normalizedQuery };
                }

                // Fun√ß√£o para buscar representantes com busca inteligente e m√∫ltiplos crit√©rios
                function searchRepresentatives(query) {
                    if (!query) return [];

                    // Detectar busca com m√∫ltiplos crit√©rios (separados por v√≠rgula, "em", "de", etc.)
                    const multiCriteriaPatterns = [
                        /(.+)\s+(em|de|no|na)\s+(.+)/i,  // "representante em S√£o Paulo"
                        /(.+),\s*(.+)/,                   // "Santos, SP" ou "SCHIOPPA, S√£o Paulo"
                        /(.+)\s-\s(.+)/                   // "SCHIOPPA - S√£o Paulo"
                    ];

                    let searchCriteria = [query];
                    let isMultiCriteria = false;

                    // Verificar se √© uma busca com m√∫ltiplos crit√©rios
                    for (const pattern of multiCriteriaPatterns) {
                        const match = query.match(pattern);
                        if (match) {
                            searchCriteria = [match[1].trim(), match[3] || match[2].trim()];
                            isMultiCriteria = true;
                            console.log(`üîç Busca multi-crit√©rio detectada: "${searchCriteria[0]}" + "${searchCriteria[1]}"`);
                            break;
                        }
                    }

                    const foundRepresentativeIds = new Set();

                    if (isMultiCriteria) {
                        // Busca com m√∫ltiplos crit√©rios - combinar resultados
                        const [criterion1, criterion2] = searchCriteria;
                        
                        // Buscar representantes que atendem o primeiro crit√©rio
                        const reps1 = searchSingleCriterion(criterion1);
                        const reps2 = searchSingleCriterion(criterion2);
                        
                        // Se um crit√©rio √© um nome de representante e outro √© localiza√ß√£o
                        const rep1Names = new Set(reps1.map(r => normalize(r.NomeRepresentante)));
                        const rep2Names = new Set(reps2.map(r => normalize(r.NomeRepresentante)));
                        
                        // Intersec√ß√£o: representantes que atendem ambos os crit√©rios
                        reps1.forEach(rep => {
                            const repName = normalize(rep.NomeRepresentante);
                            // Verificar se este representante tamb√©m atende o segundo crit√©rio
                            if (reps2.some(r => r.id === rep.id) || 
                                checkRepresentativeLocation(rep, criterion2)) {
                                foundRepresentativeIds.add(rep.id);
                            }
                        });

                        // Se n√£o houve intersec√ß√£o, tentar uni√£o (OR) para resultados mais amplos
                        if (foundRepresentativeIds.size === 0) {
                            console.log('üîç Nenhuma intersec√ß√£o encontrada, aplicando busca OR');
                            reps1.forEach(rep => foundRepresentativeIds.add(rep.id));
                            reps2.forEach(rep => foundRepresentativeIds.add(rep.id));
                        }
                    } else {
                        // Busca simples
                        const results = searchSingleCriterion(query);
                        results.forEach(rep => foundRepresentativeIds.add(rep.id));
                    }

                    return representativesData.filter(rep => foundRepresentativeIds.has(rep.id));
                }

                // Fun√ß√£o auxiliar para busca por crit√©rio √∫nico
                function searchSingleCriterion(query) {
                    const searchType = determineSearchType(query);
                    const normalizedQuery = searchType.query;
                    const foundRepresentativeIds = new Set();

                    console.log(`üîç Tipo de busca: ${searchType.type} para "${query}"`);

                    switch (searchType.type) {
                        case 'estado':
                            // Busca por estado - mais direta
                            for (const [location, repIds] of representativesByLocation.entries()) {
                                if (normalize(location).includes(normalizedQuery)) {
                                    repIds.forEach(id => foundRepresentativeIds.add(id));
                                }
                            }
                            break;

                        case 'bairro':
                            // Busca por bairro - sempre buscar, independente da bairrosLayer estar carregada
                            const bairroResults = searchInBairros(normalizedQuery);
                            bairroResults.forEach(id => foundRepresentativeIds.add(id));
                            
                            // Fallback para busca geral
                            for (const [location, repIds] of representativesByLocation.entries()) {
                                if (normalize(location).includes(normalizedQuery)) {
                                    repIds.forEach(id => foundRepresentativeIds.add(id));
                                }
                            }
                            break;

                        case 'cidade':
                            // Busca por cidade - implementar busca fuzzy inteligente
                            const cidadeResults = searchInCidades(normalizedQuery);
                            cidadeResults.forEach(id => foundRepresentativeIds.add(id));
                            break;
                    }

                    // Busca adicional por nome do representante, contato, email
                    representativesData.forEach(rep => {
                        if (normalize(rep.NomeRepresentante).includes(normalizedQuery) ||
                            normalize(rep.Contato).includes(normalizedQuery) ||
                            normalize(rep.email).includes(normalizedQuery)) {
                            foundRepresentativeIds.add(rep.id);
                        }
                    });

                    return representativesData.filter(rep => foundRepresentativeIds.has(rep.id));
                }

                // Fun√ß√£o auxiliar para verificar se um representante atende uma localiza√ß√£o
                function checkRepresentativeLocation(representative, locationQuery) {
                    const normalizedLocation = normalize(locationQuery);
                    
                    // Verificar nos estados atendidos
                    if (representative.EstadosDetalhados) {
                        for (const [estado, dadosEstado] of Object.entries(representative.EstadosDetalhados)) {
                            if (normalize(estado).includes(normalizedLocation)) {
                                return true;
                            }
                            
                            // Verificar nas cidades
                            if (dadosEstado.cidades) {
                                for (const cidade of dadosEstado.cidades) {
                                    if (normalize(cidade).includes(normalizedLocation)) {
                                        return true;
                                    }
                                }
                            }
                            
                            // Verificar nos bairros (para SP)
                            if (dadosEstado.bairros) {
                                for (const bairro of dadosEstado.bairros) {
                                    if (normalize(bairro).includes(normalizedLocation)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    
                    return false;
                }

                // --- FUN√á√ïES PARA BUSCA MELHORADA ---

                // Gerar sugest√µes inteligentes
                function generateSuggestions(query) {
                    if (!query || query.length < 2) return [];
                    
                    const suggestions = [];
                    const normalizedQuery = normalize(query);
                    const maxSuggestions = 8;
                    
                    // 1. Estados
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'estados') {
                        const estados = ['S√£o Paulo', 'Rio de Janeiro', 'Minas Gerais', 'Bahia', 'Paran√°', 'Rio Grande do Sul', 
                                       'Pernambuco', 'Cear√°', 'Par√°', 'Santa Catarina', 'Goi√°s', 'Maranh√£o', 'Para√≠ba', 
                                       'Amazonas', 'Esp√≠rito Santo', 'Mato Grosso', 'Alagoas', 'Piau√≠', 'Distrito Federal', 
                                       'Mato Grosso do Sul', 'Sergipe', 'Rio Grande do Norte', 'Rond√¥nia', 'Acre', 'Amap√°', 
                                       'Roraima', 'Tocantins'];
                        
                        estados.forEach(estado => {
                            const normalizedEstado = normalize(estado);
                            if (normalizedEstado.includes(normalizedQuery) && suggestions.length < maxSuggestions) {
                                const similarity = calculateSimilarity(normalizedEstado, normalizedQuery);
                                suggestions.push({
                                    type: 'estado',
                                    text: estado,
                                    similarity,
                                    priority: normalizedEstado.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                });
                            }
                        });
                    }
                    
                    // 2. Cidades (baseado nos dados dos representantes)
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'cidades') {
                        const cidadesSet = new Set();
                        representativesData.forEach(rep => {
                            if (rep.EstadosDetalhados) {
                                Object.values(rep.EstadosDetalhados).forEach(estadoData => {
                                    if (estadoData.cidades) {
                                        estadoData.cidades.forEach(cidade => {
                                            const normalizedCidade = normalize(cidade);
                                            if (normalizedCidade.includes(normalizedQuery) && !cidadesSet.has(cidade) && suggestions.length < maxSuggestions) {
                                                cidadesSet.add(cidade);
                                                const similarity = calculateSimilarity(normalizedCidade, normalizedQuery);
                                                suggestions.push({
                                                    type: 'cidade',
                                                    text: cidade,
                                                    similarity,
                                                    priority: normalizedCidade.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                    
                    // 3. Bairros de S√£o Paulo
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'bairros') {
                        const bairrosSet = new Set();
                        representativesData.forEach(rep => {
                            if (rep.EstadosDetalhados && rep.EstadosDetalhados.SP && rep.EstadosDetalhados.SP.bairros) {
                                rep.EstadosDetalhados.SP.bairros.forEach(bairro => {
                                    const normalizedBairro = normalize(bairro);
                                    if (normalizedBairro.includes(normalizedQuery) && !bairrosSet.has(bairro) && suggestions.length < maxSuggestions) {
                                        bairrosSet.add(bairro);
                                        const similarity = calculateSimilarity(normalizedBairro, normalizedQuery);
                                        suggestions.push({
                                            type: 'bairro',
                                            text: bairro + ' (SP)',
                                            originalText: bairro,
                                            similarity,
                                            priority: normalizedBairro.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                        });
                                    }
                                });
                            }
                        });
                    }
                    
                    // 4. Representantes
                    if (currentSearchFilter === 'all' || currentSearchFilter === 'representantes') {
                        representativesData.forEach(rep => {
                            const normalizedRep = normalize(rep.NomeRepresentante);
                            if (normalizedRep.includes(normalizedQuery) && suggestions.length < maxSuggestions) {
                                const similarity = calculateSimilarity(normalizedRep, normalizedQuery);
                                suggestions.push({
                                    type: 'representante',
                                    text: rep.NomeRepresentante,
                                    similarity,
                                    priority: normalizedRep.startsWith(normalizedQuery) ? 3 : similarity > 0.8 ? 2 : 1
                                });
                            }
                        });
                    }
                    
                    // 5. Sugest√µes combinadas (apenas se h√° texto suficiente)
                    if (query.length >= 4 && suggestions.length < maxSuggestions - 2) {
                        // Sugerir combina√ß√µes populares
                        const popularCombinations = [
                            'SCHIOPPA em S√£o Paulo',
                            '3L em Bauru',
                            'representantes em SP',
                            'Santos, SP',
                            'Campinas, SP'
                        ];
                        
                        popularCombinations.forEach(combo => {
                            if (normalize(combo).includes(normalizedQuery) && suggestions.length < maxSuggestions) {
                                suggestions.push({
                                    type: 'combinado',
                                    text: combo,
                                    similarity: 0.6,
                                    priority: 1
                                });
                            }
                        });
                    }
                    
                    // Ordenar por prioridade e similaridade
                    return suggestions
                        .sort((a, b) => {
                            if (a.priority !== b.priority) return b.priority - a.priority;
                            return b.similarity - a.similarity;
                        })
                        .slice(0, maxSuggestions);
                }

                // Mostrar sugest√µes
                function showSuggestions(suggestions) {
                    if (suggestions.length === 0) {
                        hideSuggestions();
                        return;
                    }
                    
                    suggestionsList.innerHTML = '';
                    selectedSuggestionIndex = -1;
                    
                    suggestions.forEach((suggestion, index) => {
                        const item = document.createElement('div');
                        item.className = 'suggestion-item';
                        
                        // √çcone baseado no tipo
                        let icon = 'search';
                        switch(suggestion.type) {
                            case 'estado': icon = 'map'; break;
                            case 'cidade': icon = 'map-pin'; break;
                            case 'bairro': icon = 'home'; break;
                            case 'representante': icon = 'user'; break;
                            case 'combinado': icon = 'link'; break;
                        }
                        
                        item.innerHTML = `
                            <div class="flex items-center gap-2">
                                <i data-lucide="${icon}" class="h-3 w-3 text-gray-400"></i>
                                <span>${suggestion.text}</span>
                            </div>
                            <span class="suggestion-type">${suggestion.type}</span>
                        `;
                        
                        item.addEventListener('click', () => {
                            selectSuggestion(suggestion);
                        });
                        
                        suggestionsList.appendChild(item);
                    });
                    
                    // Adicionar instru√ß√£o sutil no final das sugest√µes
                    if (suggestions.length > 0) {
                        const instructionItem = document.createElement('div');
                        instructionItem.className = 'suggestion-instruction text-xs text-gray-500 p-2 border-t border-gray-100 text-center';
                        instructionItem.innerHTML = 'Clique em uma sugest√£o ou pressione Enter para buscar';
                        suggestionsList.appendChild(instructionItem);
                    }
                    
                    searchSuggestions = suggestions;
                    suggestionsContainer.classList.remove('hidden');
                    
                    // Adicionar classe para indicar que h√° sugest√µes
                    searchInput.classList.add('has-suggestions');
                    
                    // Inicializar √≠cones Lucide para as novas sugest√µes
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                }

                // Esconder sugest√µes
                function hideSuggestions() {
                    suggestionsContainer.classList.add('hidden');
                    selectedSuggestionIndex = -1;
                    searchInput.classList.remove('has-suggestions');
                }

                // Selecionar sugest√£o
                function selectSuggestion(suggestion) {
                    const textToUse = suggestion.originalText || suggestion.text;
                    searchInput.value = textToUse;
                    hideSuggestions();
                    handleSearch();
                    addToRecentSearches(textToUse);
                }

                // Adicionar ao hist√≥rico de buscas recentes
                function addToRecentSearches(searchTerm) {
                    if (!searchTerm.trim()) return;
                    
                    // Remove duplicatas e adiciona no in√≠cio
                    recentSearchesData = recentSearchesData.filter(item => item !== searchTerm);
                    recentSearchesData.unshift(searchTerm);
                    
                    // Limita a 5 itens
                    recentSearchesData = recentSearchesData.slice(0, 5);
                    
                    // Salva no localStorage
                    localStorage.setItem('recentSearches', JSON.stringify(recentSearchesData));
                    
                    updateRecentSearchesDisplay();
                }

                // Atualizar exibi√ß√£o do hist√≥rico
                function updateRecentSearchesDisplay() {
                    if (recentSearchesData.length === 0) {
                        recentSearches.classList.add('hidden');
                        return;
                    }
                    
                    recentSearchesList.innerHTML = '';
                    recentSearchesData.forEach(searchTerm => {
                        const item = document.createElement('span');
                        item.className = 'recent-search-item';
                        item.textContent = searchTerm;
                        item.addEventListener('click', () => {
                            searchInput.value = searchTerm;
                            handleSearch();
                        });
                        recentSearchesList.appendChild(item);
                    });
                    
                    recentSearches.classList.remove('hidden');
                }

                // Atualizar destaque das sugest√µes
                function updateSuggestionHighlight() {
                    const suggestionItems = suggestionsList.querySelectorAll('.suggestion-item');
                    suggestionItems.forEach((item, index) => {
                        if (index === selectedSuggestionIndex) {
                            item.classList.add('highlighted');
                        } else {
                            item.classList.remove('highlighted');
                        }
                    });
                }

                // Fun√ß√£o para buscar em bairros de S√£o Paulo
                function searchInBairros(query) {
                    const foundIds = new Set();
                    const normalizedQuery = normalize(query);
                    
                    console.log(`üîç Buscando bairros para: "${query}" (normalizado: "${normalizedQuery}")`);
                    
                    // M√âTODO 1: Busca direta no municipioRepresentativeMap
                    const directMatch = municipioRepresentativeMap.get(normalizedQuery);
                    if (directMatch && directMatch.length > 0) {
                        directMatch.forEach(rep => {
                            console.log(`‚úÖ Match direto encontrado no municipioRepresentativeMap: "${query}" para representante "${rep.NomeRepresentante}"`);
                            foundIds.add(rep.id);
                        });
                    }
                    
                    // M√âTODO 2: Buscar em todos os representantes que t√™m bairros mapeados
                    representativesData.forEach(rep => {
                        if (rep.EstadosDetalhados && rep.EstadosDetalhados.SP && rep.EstadosDetalhados.SP.bairros) {
                            const bairros = rep.EstadosDetalhados.SP.bairros;
                            
                            bairros.forEach(bairro => {
                                const normalizedBairro = normalize(bairro);
                                
                                // Busca exata primeiro
                                if (normalizedBairro === normalizedQuery) {
                                    console.log(`‚úÖ Match exato encontrado: "${bairro}" para representante "${rep.NomeRepresentante}"`);
                                    foundIds.add(rep.id);
                                    return;
                                }
                                
                                // Busca por cont√©m (para bairros que come√ßam com a query)
                                if (normalizedBairro.includes(normalizedQuery) && normalizedQuery.length >= 3) {
                                    console.log(`üîç Match por cont√©m encontrado: "${bairro}" para representante "${rep.NomeRepresentante}"`);
                                    foundIds.add(rep.id);
                                    return;
                                }
                                
                                // Busca por similaridade (Levenshtein)
                                const similarity = calculateSimilarity(normalizedBairro, normalizedQuery);
                                if (similarity > 0.7) { // Threshold de 70% de similaridade
                                    console.log(`üîç Match similar encontrado: "${bairro}" (${(similarity * 100).toFixed(1)}%) para representante "${rep.NomeRepresentante}"`);
                                    foundIds.add(rep.id);
                                }
                            });
                        }
                    });
                    
                    console.log(`üìä Total de representantes encontrados para bairros: ${foundIds.size}`);
                    return foundIds;
                }

                // Fun√ß√£o para buscar em cidades com diferencia√ß√£o inteligente
                function searchInCidades(query) {
                    const foundIds = new Set();
                    const exactMatches = [];
                    const partialMatches = [];
                    const similarMatches = [];
                    
                    // Coletar todas as cidades √∫nicas com seus estados
                    const cidadesUnicas = new Map(); // cidade -> [estados]
                    
                    representativesData.forEach(rep => {
                        if (rep.EstadosDetalhados) {
                            Object.entries(rep.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                                if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                    dadosEstado.cidades.forEach(cidade => {
                                        const normalizedCidade = normalize(cidade);
                                        if (!cidadesUnicas.has(normalizedCidade)) {
                                            cidadesUnicas.set(normalizedCidade, []);
                                        }
                                        if (!cidadesUnicas.get(normalizedCidade).includes(estado)) {
                                            cidadesUnicas.get(normalizedCidade).push(estado);
                                        }
                                    });
                                }
                            });
                        }
                    });
                    
                    // Classificar as cidades por tipo de match
                    for (const [cidade, estados] of cidadesUnicas.entries()) {
                        // 1. Match exato
                        if (cidade === query) {
                            exactMatches.push({ cidade, estados });
                        }
                        // 2. Match parcial (come√ßa com a query)
                        else if (cidade.startsWith(query) && query.length >= 3) {
                            partialMatches.push({ cidade, estados });
                        }
                        // 3. Match por similaridade
                        else {
                            const similarity = calculateSimilarity(cidade, query);
                            if (similarity > 0.7) { // Threshold de 70% de similaridade
                                similarMatches.push({ cidade, estados, similarity });
                            }
                        }
                    }
                    
                    // Ordenar matches similares por similaridade
                    similarMatches.sort((a, b) => b.similarity - a.similarity);
                    
                    // Processar matches exatos primeiro
                    exactMatches.forEach(({ cidade, estados }) => {
                        const representatives = getRepresentativesByCidade(cidade, estados);
                        representatives.forEach(rep => foundIds.add(rep.id));
                    });
                    
                    // Se n√£o h√° matches exatos, processar parciais
                    if (exactMatches.length === 0 && partialMatches.length > 0) {
                        partialMatches.forEach(({ cidade, estados }) => {
                            const representatives = getRepresentativesByCidade(cidade, estados);
                            representatives.forEach(rep => foundIds.add(rep.id));
                        });
                    }
                    
                    // Se ainda n√£o h√° resultados, processar similares
                    if (foundIds.size === 0 && similarMatches.length > 0) {
                        // Limitar a 3 matches similares para evitar polui√ß√£o
                        similarMatches.slice(0, 3).forEach(({ cidade, estados }) => {
                            const representatives = getRepresentativesByCidade(cidade, estados);
                            representatives.forEach(rep => foundIds.add(rep.id));
                        });
                    }
                    
                    return foundIds;
                }

                // Fun√ß√£o para obter representantes por cidade e estados
                function getRepresentativesByCidade(cidade, estados) {
                    const representatives = [];
                    
                    representativesData.forEach(rep => {
                        if (rep.EstadosDetalhados) {
                            Object.entries(rep.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                                if (estados.includes(estado) && dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                    if (dadosEstado.cidades.some(c => normalize(c) === cidade)) {
                                        representatives.push(rep);
                                    }
                                }
                            });
                        }
                    });
                    
                    return representatives;
                }

                // Fun√ß√£o para buscar representantes por localiza√ß√£o espec√≠fica
                function getRepresentativesByLocation(location) {
                    const repIds = representativesByLocation.get(location) || new Set();
                    return representativesData.filter(rep => repIds.has(rep.id));
                }

                // --- FUN√á√ïES DE INICIALIZA√á√ÉO ---

                async function initializeApp() {
                    try {
                        const [rawRepData, rawMunicipiosData] = await Promise.all([
                            fetchJsonData(jsonFileUrl),
                            fetchJsonData(municipiosJsonUrl)
                        ]);

                        representativesData = transformRepresentativesData(rawRepData);
                        municipiosData = rawMunicipiosData;

                        // Mapear SCHIOPPA para todos os munic√≠pios dos seus estados
                        mapSchioppaToAllMunicipios();

                        // Debug: Verificar estrutura dos dados de munic√≠pios
                        if (municipiosData.features && municipiosData.features.length > 0) {
                            console.log('Estrutura do primeiro munic√≠pio:', municipiosData.features[0].properties);
                            console.log('Total de munic√≠pios carregados:', municipiosData.features.length);
                            console.log('Propriedades dispon√≠veis:', Object.keys(municipiosData.features[0].properties));
                        }

                        await setupMap();
                        setupEventListeners();
                        
                        // Inicializar funcionalidades de busca melhorada
                        updateRecentSearchesDisplay();
                        
                        // Inicializar √≠cones Lucide
                        if (typeof lucide !== 'undefined') {
                            lucide.createIcons();
                        }
                        
                        loadingIndicator.classList.add('hidden');
                        defaultMessage.classList.remove('hidden');
                    } catch (error) {
                        console.error("Erro ao inicializar a aplica√ß√£o:", error);
                        initialMessage.innerHTML = `<p class="text-red-500 text-center">Falha ao carregar os dados. Verifique a conex√£o.</p>`;
                    }
                }

                async function fetchJsonData(url) {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`N√£o foi poss√≠vel buscar o arquivo: ${response.statusText}`);
                    return await response.json();
                }

                async function setupMap() {
                    map = L.map('map', { zoomControl: true, attributionControl: false }).setView([-15.78, -47.92], 4);

                    const response = await fetch(brazilStatesGeoJsonUrl);
                    const brazilGeoJson = await response.json();

                    geoJsonLayer = L.geoJson(brazilGeoJson, {
                        style: defaultMapStyle,
                        onEachFeature: onEachStateFeature,
                        interactive: true
                    }).addTo(map);

                    // Configurar a layer dos estados para ter prioridade
                    geoJsonLayer.setZIndex(10);

                    // Carregar e adicionar camada dos bairros de S√£o Paulo
                    try {
                        const bairrosResponse = await fetch(bairrosGeoJsonUrl);
                        const bairrosGeoJson = await bairrosResponse.json();

                        bairrosLayer = L.geoJson(bairrosGeoJson, {
                            style: function (feature) {
                                const bairroName = feature.properties.NOME_DIST;
                                if (bairroName) {
                                    const normalizedBairroName = normalize(bairroName);
                                    
                                    // IMPORTANTE: Buscar representantes considerando o estado atual (SP para bairros)
                                    let representatives = [];
                                    if (viewMode === 'municipios' && currentState && currentState.code === 'SP') {
                                        // Para bairros de SP, usar a chave cidade+estado
                                        const cidadeEstadoKey = `${normalizedBairroName}-SP`;
                                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                                        
                                        // Se n√£o encontrar com chave composta, tentar s√≥ o nome (compatibilidade)
                                        if (representatives.length === 0) {
                                            representatives = municipioRepresentativeMap.get(normalizedBairroName) || [];
                                        }
                                    }
                                    // Se n√£o estivermos em SP ou no modo correto, n√£o colorir bairros

                                    if (representatives.length > 0) {
                                        // Se h√° representantes, usar a cor do primeiro representante
                                        const firstRep = representatives[0];
                                        const color = representativeColorMap.get(firstRep.id) || '#9CA3AF';

                                        return {
                                            color: '#DC2626',        // Vermelho para o contorno
                                            weight: 3,
                                            opacity: 1,
                                            dashArray: '8,6',        // Pontilhado/dashed
                                            fillColor: color,
                                            fillOpacity: 0.7,
                                            // Stroke branco por fora ser√° aplicado via CSS
                                            className: 'bairro-with-rep'
                                        };
                                    }
                                }

                                // Estilo padr√£o para bairros sem representantes
                                return {
                                    color: '#DC2626',        // Vermelho para o contorno
                                    weight: 2,
                                    opacity: 0.6,
                                    dashArray: '6,4',        // Pontilhado mais sutil
                                    fillColor: '#999',
                                    fillOpacity: 0.2,
                                    className: 'bairro-without-rep'
                                };
                            },
                            onEachFeature: function (feature, layer) {
                                const bairroName = feature.properties.NOME_DIST;
                                if (bairroName) {
                                    // Buscar representantes para este bairro
                                    const normalizedBairroName = normalize(bairroName);
                                    const representatives = municipioRepresentativeMap.get(normalizedBairroName) || [];

                                    // Tooltip com informa√ß√µes do bairro e representantes
                                    let tooltipContent = `<strong>${bairroName}</strong>`;
                                    if (representatives.length > 0) {
                                        tooltipContent += `<br><small>Representantes: ${representatives.length}</small>`;
                                        representatives.forEach((rep, index) => {
                                            const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                                            tooltipContent += `<br><span style="color: ${color}; font-weight: bold;">‚Ä¢</span> ${rep.NomeRepresentante}`;
                                            if (rep.Contato) {
                                                tooltipContent += ` (${rep.Contato})`;
                                            }
                                        });
                                    } else {
                                        tooltipContent += `<br><small style="color: #6B7280;">Sem representantes</small>`;
                                    }

                                    layer.bindTooltip(tooltipContent, {
                                        permanent: false,
                                        direction: 'top',
                                        className: 'bairro-tooltip'
                                    });

                                    // Adicionar evento de clique para zoom na capital de S√£o Paulo
                                    layer.on('click', function (e) {
                                        // Coordenadas aproximadas da capital de S√£o Paulo
                                        const capitalBounds = L.latLngBounds(
                                            [-23.8, -46.8],  // Sudoeste
                                            [-23.4, -46.4]   // Nordeste
                                        );

                                        map.fitBounds(capitalBounds, {
                                            padding: [30, 30],
                                            maxZoom: 10  // Zoom para mostrar toda a capital
                                        });
                                        console.log('üèôÔ∏è Zoom aplicado na capital de S√£o Paulo');
                                    });
                                }
                            },
                            interactive: true
                        }).addTo(map);

                        // Configurar a layer dos bairros para ter prioridade menor que os estados
                        bairrosLayer.setZIndex(5);

                        // Inicialmente, os bairros ficam ocultos
                        bairrosLayer.remove();

                        console.log('‚úÖ Camada dos bairros de S√£o Paulo carregada com sucesso');
                    } catch (error) {
                        console.warn('‚ö†Ô∏è N√£o foi poss√≠vel carregar a camada dos bairros:', error);
                    }

                    // Adicionar listener global no mapa para interceptar cliques
                    map.on('click', handleGlobalMapClick);

                    map.fitBounds(geoJsonLayer.getBounds());
                }

                function handleGlobalMapClick(e) {
                    const latlng = e.latlng;
                    console.log('Clique global detectado em:', latlng);

                    // Fun√ß√£o para verificar se um ponto est√° dentro de um pol√≠gono (ray casting)
                    function pointInPolygon(point, polygon) {
                        const x = point.lat, y = point.lng;
                        let inside = false;

                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            const xi = polygon[i].lat, yi = polygon[i].lng;
                            const xj = polygon[j].lat, yj = polygon[j].lng;

                            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                                inside = !inside;
                            }
                        }
                        return inside;
                    }

                    // Verificar munic√≠pios PRIMEIRO se a camada estiver dispon√≠vel
                    // (mesmo no modo 'states' se os dados estiverem carregados)
                    if (municipiosLayer) {
                        console.log('üîç Verificando munic√≠pios primeiro (dados de munic√≠pios dispon√≠veis)');
                        let clickedMunicipio = null;
                        municipiosLayer.eachLayer(layer => {
                            if (layer.getBounds().contains(latlng)) {
                                const feature = layer.feature;
                                if (feature.geometry.type === 'Polygon') {
                                    const coords = feature.geometry.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                    if (pointInPolygon(latlng, coords)) {
                                        clickedMunicipio = layer;
                                    }
                                } else if (feature.geometry.type === 'MultiPolygon') {
                                    for (let polygon of feature.geometry.coordinates) {
                                        const coords = polygon[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                        if (pointInPolygon(latlng, coords)) {
                                            clickedMunicipio = layer;
                                            break;
                                        }
                                    }
                                }
                            }
                        });

                        if (clickedMunicipio) {
                            const props = clickedMunicipio.feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            if (municipioName) {
                                console.log('‚úÖ Clique interceptado em MUNIC√çPIO:', municipioName);
                                console.log('üìç Estado atual:', currentState);
                                console.log('üìç ViewMode:', viewMode);

                                // Verificar a qual estado o munic√≠pio pertence
                                const municipioState = getMunicipioState(props);
                                console.log('üìç Estado do munic√≠pio:', municipioState);

                                // Se estamos no modo 'states' e n√£o temos estado selecionado,
                                // ou se o munic√≠pio pertence a um estado diferente do atual
                                if ((viewMode === 'states' && !currentState) || 
                                    (currentState && municipioState && municipioState !== currentState.code)) {
                                    console.log('üîÑ Carregando estado para visualizar munic√≠pio...');

                                    // Encontrar o estado correto no mapa
                                    const targetStateLayer = findStateLayerByCode(municipioState);
                                    if (targetStateLayer) {
                                        console.log('üîÑ Carregando estado:', municipioState);
                                        
                                        // Armazenar o nome do munic√≠pio para filtrar ap√≥s carregar o estado
                                        const targetMunicipio = municipioName;
                                        
                                        const fakeEvent = {
                                            target: targetStateLayer,
                                            latlng: latlng,
                                            originalEvent: e.originalEvent
                                        };
                                        
                                        // Carregar o estado e depois filtrar o munic√≠pio espec√≠fico
                                        handleStateClick(fakeEvent);
                                        
                                        // Aguardar o carregamento do estado e depois filtrar pelo munic√≠pio
                                        setTimeout(() => {
                                            console.log('üéØ Filtrando munic√≠pio ap√≥s carregar estado:', targetMunicipio);
                                            filterByMunicipio(targetMunicipio);
                                        }, 800); // Delay para garantir que o estado foi carregado
                                        return;
                                    }
                                }

                                // Reset do munic√≠pio selecionado anterior
                                if (selectedMunicipioLayer) {
                                    municipiosLayer.resetStyle(selectedMunicipioLayer);
                                }

                                // Selecionar o novo munic√≠pio
                                selectedMunicipioLayer = clickedMunicipio;
                                selectedMunicipioLayer.setStyle(municipioSelectedStyle);

                                // Mostrar os representantes do munic√≠pio
                                filterByMunicipio(municipioName);

                                // Scroll para os resultados
                                document.getElementById('results-container').scrollIntoView({ behavior: 'smooth' });
                                return; // Parar aqui, n√£o processar estado
                            }
                        } else {
                            console.log('‚ùå Nenhum munic√≠pio encontrado no clique - verificando se √© clique em estado diferente');

                            // Se n√£o encontrou munic√≠pio, verificar se √© clique em estado diferente
                            let clickedState = null;
                            geoJsonLayer.eachLayer(layer => {
                                if (layer.getBounds().contains(latlng)) {
                                    const feature = layer.feature;
                                    if (feature.geometry.type === 'Polygon') {
                                        const coords = feature.geometry.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                        if (pointInPolygon(latlng, coords)) {
                                            clickedState = layer;
                                        }
                                    } else if (feature.geometry.type === 'MultiPolygon') {
                                        for (let polygon of feature.geometry.coordinates) {
                                            const coords = polygon[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                            if (pointInPolygon(latlng, coords)) {
                                                clickedState = layer;
                                                break;
                                            }
                                        }
                                    }
                                }
                            });

                            if (clickedState) {
                                const clickedStateCode = getStateCode(clickedState.feature.properties);
                                const clickedStateName = clickedState.feature.properties.nome || clickedState.feature.properties.name || clickedState.feature.properties.NAME;

                                // Verificar se √© um estado diferente do atual
                                if (currentState && currentState.code !== clickedStateCode) {
                                    console.log('üîÑ Clique em estado diferente detectado:', clickedStateName, '(', clickedStateCode, ')');
                                    console.log('üîÑ Estado atual:', currentState.name, '(', currentState.code, ')');

                                    // Fazer reset completo e carregar novo estado
                                    const fakeEvent = {
                                        target: clickedState,
                                        latlng: latlng,
                                        originalEvent: e.originalEvent
                                    };
                                    handleStateClick(fakeEvent);
                                    return;
                                }
                            }
                        }
                    }

                    // Se n√£o clicou em munic√≠pio ou n√£o estamos no modo munic√≠pios, verificar estados
                    console.log('üîç Verificando estados...');
                    let clickedState = null;
                    geoJsonLayer.eachLayer(layer => {
                        if (layer.getBounds().contains(latlng)) {
                            // Verifica√ß√£o mais precisa usando geometria
                            const feature = layer.feature;
                            if (feature.geometry.type === 'Polygon') {
                                const coords = feature.geometry.coordinates[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                if (pointInPolygon(latlng, coords)) {
                                    clickedState = layer;
                                }
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                for (let polygon of feature.geometry.coordinates) {
                                    const coords = polygon[0].map(coord => ({ lat: coord[1], lng: coord[0] }));
                                    if (pointInPolygon(latlng, coords)) {
                                        clickedState = layer;
                                        break;
                                    }
                                }
                            }
                        }
                    });

                    // Se clicou em um estado, processar como estado
                    if (clickedState) {
                        console.log('‚úÖ Clique interceptado em ESTADO');

                        // Verificar se √© um clique em um estado diferente do atual
                        const clickedStateCode = getStateCode(clickedState.feature.properties);
                        const clickedStateName = clickedState.feature.properties.nome || clickedState.feature.properties.name || clickedState.feature.properties.NAME;

                        if (currentState && currentState.code !== clickedStateCode) {
                            console.log('üîÑ Clique em estado diferente detectado. Fazendo reset completo...');
                            // √â um clique em um estado diferente - fazer reset completo
                            const fakeEvent = {
                                target: clickedState,
                                latlng: latlng,
                                originalEvent: e.originalEvent
                            };
                            handleStateClick(fakeEvent);
                        } else if (!currentState) {
                            // Primeiro clique em um estado
                            const fakeEvent = {
                                target: clickedState,
                                latlng: latlng,
                                originalEvent: e.originalEvent
                            };
                            handleStateClick(fakeEvent);
                        }
                    }
                }

                function setupEventListeners() {
                    let debounceTimeout;
                    let suggestionTimeout;
                    
                    // Input da busca com sugest√µes
                    searchInput.addEventListener('input', function () {
                        const query = this.value.trim();
                        
                        // Mostrar/esconder bot√£o de limpar
                        if (query) {
                            clearSearchButton.classList.remove('hidden');
                        } else {
                            clearSearchButton.classList.add('hidden');
                            hideSuggestions();
                        }
                        
                        // Gerar sugest√µes com debounce menor
                        clearTimeout(suggestionTimeout);
                        if (query.length >= 2) {
                            suggestionTimeout = setTimeout(() => {
                                const suggestions = generateSuggestions(query);
                                showSuggestions(suggestions);
                            }, 150);
                        } else {
                            hideSuggestions();
                        }
                        
                        // Remover busca autom√°tica - s√≥ buscar quando usu√°rio clicar ou pressionar Enter
                        clearTimeout(debounceTimeout);
                    });
                    
                    // Navega√ß√£o por teclado nas sugest√µes
                    searchInput.addEventListener('keydown', function(e) {
                        if (searchSuggestions.length === 0) return;
                        
                        switch(e.key) {
                            case 'ArrowDown':
                                e.preventDefault();
                                selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, searchSuggestions.length - 1);
                                updateSuggestionHighlight();
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                                updateSuggestionHighlight();
                                break;
                            case 'Enter':
                                e.preventDefault();
                                if (selectedSuggestionIndex >= 0) {
                                    selectSuggestion(searchSuggestions[selectedSuggestionIndex]);
                                } else if (searchSuggestions.length === 0 || suggestionsContainer.classList.contains('hidden')) {
                                    // S√≥ executa busca se n√£o h√° sugest√µes vis√≠veis
                                    hideSuggestions();
                                    handleSearch();
                                    if (this.value.trim()) {
                                        addToRecentSearches(this.value.trim());
                                    }
                                }
                                // Se h√° sugest√µes vis√≠veis, n√£o faz nada - usu√°rio deve escolher uma sugest√£o
                                break;
                            case 'Escape':
                                hideSuggestions();
                                break;
                        }
                    });
                    
                    // Focus no input para mostrar hist√≥rico
                    searchInput.addEventListener('focus', function() {
                        if (!this.value && recentSearchesData.length > 0) {
                            updateRecentSearchesDisplay();
                        }
                    });
                    
                    // Bot√£o de limpar busca
                    clearSearchButton.addEventListener('click', function() {
                        searchInput.value = '';
                        clearSearchButton.classList.add('hidden');
                        hideSuggestions();
                        resetView(true);
                        searchInput.focus();
                    });
                    
                    // Filtros de busca
                    searchFilters.forEach(filter => {
                        filter.addEventListener('click', function() {
                            // Atualizar filtro ativo
                            searchFilters.forEach(f => f.classList.remove('active'));
                            this.classList.add('active');
                            currentSearchFilter = this.dataset.filter;
                            
                            // Regenerar sugest√µes se h√° texto
                            if (searchInput.value.trim().length >= 2) {
                                const suggestions = generateSuggestions(searchInput.value.trim());
                                showSuggestions(suggestions);
                            }
                            
                            // Re-executar busca se h√° resultados
                            if (searchInput.value.trim()) {
                                handleSearch();
                            }
                        });
                    });
                    
                    // Clique fora das sugest√µes para esconder (com delay para dar tempo de clicar)
                    document.addEventListener('click', function(e) {
                        if (!suggestionsContainer.contains(e.target) && e.target !== searchInput) {
                            // Pequeno delay para permitir cliques nas sugest√µes
                            setTimeout(() => {
                                if (!suggestionsContainer.contains(document.activeElement)) {
                                    hideSuggestions();
                                    recentSearches.classList.add('hidden');
                                }
                            }, 100);
                        }
                    });

                    backButton.addEventListener('click', resetView);

                    // Event listener para o bot√£o de reset zoom
                    const resetZoomBtn = document.getElementById('reset-zoom-btn');
                    resetZoomBtn.addEventListener('click', function () {
                        resetView(false); // false para n√£o limpar a busca
                    });

                    // Event listener para o bot√£o de maximizar mapa
                    const maximizeMapBtn = document.getElementById('maximize-map-btn');
                    maximizeMapBtn.addEventListener('click', function () {
                        toggleMapMaximize();
                    });
                }

                // --- ESTILOS DO MAPA ---

                const defaultMapStyle = { fillColor: "#3b82f6", weight: 1, opacity: 1, color: 'white', fillOpacity: 0.7 };
                const highlightMapStyle = { weight: 0, color: '#fbbf24', fillOpacity: 0.9 };
                const selectedMapStyle = { fillColor: "#fbbf24", fillOpacity: 1 };
                const municipioSelectedStyle = { fillColor: "#fbbf24", weight: 2, opacity: 1, color: '#f59e0b', fillOpacity: 0.9 };

                // Fun√ß√£o para obter estilo do munic√≠pio baseado no representante
                function getMunicipioStyleByRepresentative(municipioName) {
                    const normalizedName = normalize(municipioName);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    // Buscar representantes considerando o estado atual apenas quando estamos visualizando munic√≠pios
                    let representatives = [];
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        const normalizedEstado = normalize(currentState.code);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                        
                    } else {
                        // IMPORTANTE: N√£o fazer busca apenas por cidade para evitar conflitos
                        // Se n√£o temos estado espec√≠fico, n√£o podemos determinar qual cidade espec√≠fica
                        representatives = [];
                    }

                    if (representatives.length === 0) {
                        // Munic√≠pio sem representante - cor azul padr√£o
                        return {
                            fillColor: "#3b82f6",
                            weight: 1,
                            opacity: 1,
                            color: 'white',
                            fillOpacity: 0.6
                        };
                    }

                    // Se h√° m√∫ltiplos representantes, usar a cor do primeiro
                    const primaryRepresentative = representatives[0];
                    const color = representativeColorMap.get(primaryRepresentative.id) || '#3b82f6';

                    return {
                        fillColor: color,
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: representatives.length > 1 ? 0.8 : 0.6 // Mais opaco se m√∫ltiplos representantes
                    };
                }

                // Fun√ß√£o para obter estilo de destaque do munic√≠pio
                function getMunicipioHighlightStyle(municipioName) {
                    const normalizedName = normalize(municipioName);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    // Buscar representantes considerando o estado atual apenas quando estamos visualizando munic√≠pios
                    let representatives = [];
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        const normalizedEstado = normalize(currentState.code);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                    } else {
                        // IMPORTANTE: N√£o fazer busca apenas por cidade para evitar conflitos
                        // Se n√£o temos estado espec√≠fico, n√£o podemos determinar qual cidade espec√≠fica
                        representatives = [];
                    }

                    if (representatives.length === 0) {
                        return { weight: 0, color: '#3b82f6', fillOpacity: 0.8 };
                    }

                    const primaryRepresentative = representatives[0];
                    const color = representativeColorMap.get(primaryRepresentative.id) || '#3b82f6';

                    return {
                        weight: 0,
                        color: color,
                        fillOpacity: 0.9
                    };
                }

                // Fun√ß√£o para criar/atualizar a legenda
                function updateLegend(stateRepresentatives = []) {
                    const legendElement = document.getElementById('legend');
                    const legendItemsElement = document.getElementById('legend-items');

                    if (!legendElement || !legendItemsElement) return;

                    // Limpar itens existentes
                    legendItemsElement.innerHTML = '';

                    if (stateRepresentatives.length === 0) {
                        legendElement.classList.add('hidden');
                        return;
                    }

                    // Criar itens da legenda
                    stateRepresentatives.forEach(rep => {
                        const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                        const legendItem = document.createElement('div');
                        legendItem.className = 'flex items-center text-xs text-gray-700';
                        legendItem.innerHTML = `
                        <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${color};"></div>
                        <span class="truncate" title="${rep.NomeRepresentante}">${rep.NomeRepresentante}</span>
                    `;
                        legendItemsElement.appendChild(legendItem);
                    });

                    legendElement.classList.remove('hidden');
                }

                // --- FUN√á√ïES DO MAPA DE ESTADOS ---

                function getStateCode(properties) {
                    // Baseado na estrutura real do uf.json
                    // Priorizar UF_05 que cont√©m a sigla do estado (ex: "CE", "AC", "BA")
                    return properties.UF_05 || properties.uf || properties.sigla ||
                        properties.SIGLA || properties.UF ||
                        // Fallback para nome completo se n√£o encontrar sigla
                        properties.NOME_UF || properties.nome || properties.NOME ||
                        properties.name || properties.NAME;
                }

                function onEachStateFeature(feature, layer) {
                    layer.on({
                        mouseover: e => {
                            if (e.target !== selectedStateLayer && viewMode === 'states') {
                                e.target.setStyle(highlightMapStyle);
                            }
                        },
                        mouseout: e => {
                            if (e.target !== selectedStateLayer && viewMode === 'states') {
                                geoJsonLayer.resetStyle(e.target);
                            }
                        }
                        // Removemos o click handler - ser√° tratado pelo listener global
                    });
                }

                function handleStateClick(e) {
                    const properties = e.target.feature.properties;
                    let stateCode = getStateCode(properties);
                    let stateName = properties.nome || properties.name || properties.NAME;

                    console.log('üéØ Estado selecionado:', stateName, stateCode);

                    // Reset completo ANTES de qualquer opera√ß√£o
                    // Reset do estado anterior se existir
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                    }

                    // Remove munic√≠pios anteriores se existirem
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    // Reset do munic√≠pio selecionado
                    selectedMunicipioLayer = null;

                    // Limpar resultados e legenda
                    showInitialMessage();
                    updateLegend([]);

                    // Seleciona o novo estado
                    selectedStateLayer = e.target;
                    selectedStateLayer.setStyle(selectedMapStyle);
                    currentState = { code: stateCode, name: stateName, layer: e.target };

                    // Aplicar zoom no estado
                    const stateBounds = e.target.getBounds();
                    console.log('üîç Aplicando zoom no estado:', stateName, 'Bounds:', stateBounds);

                    map.fitBounds(stateBounds, {
                        padding: [25, 25],
                        maxZoom: 8  // Limitar zoom m√°ximo para n√£o ficar muito pr√≥ximo
                    });

                    // Aguardar um pouco para garantir que o zoom seja aplicado antes de carregar munic√≠pios
                    setTimeout(() => {
                        // Mostra munic√≠pios e filtra representantes ap√≥s o zoom
                        showMunicipios(stateCode, stateName, e.target);
                        filterByState(stateCode);
                    }, 300); // 300ms de delay para garantir
                }

                // Filtrar munic√≠pios apenas do estado selecionado
                function showMunicipios(stateCode, stateName, stateLayer) {
                    console.log(`üîç Carregando munic√≠pios para o estado: ${stateName} (${stateCode})`);

                    // Filtrar munic√≠pios do estado usando m√∫ltiplos crit√©rios
                    const estadoMunicipios = municipiosData.features.filter(feature => {
                        const props = feature.properties;

                        // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio (formato: "UF - Munic√≠pio")
                        let municipioState = props.uf || props.estado || props.sigla_uf ||
                            props.UF || props.ESTADO || props.cd_geocuf;

                        // Se n√£o encontrou, tentar extrair do uf_municipio
                        if (!municipioState && props.uf_municipio) {
                            const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                            if (match) {
                                municipioState = match[1];
                            }
                        }

                        // Comparar com c√≥digo e nome do estado
                        const pertenceAoEstado = municipioState === stateCode ||
                            municipioState === stateName ||
                            normalize(municipioState) === normalize(stateCode) ||
                            normalize(municipioState) === normalize(stateName);

                        if (pertenceAoEstado) {
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            console.log(`‚úÖ Munic√≠pio ${municipioName} pertence ao estado ${stateName}`);
                        }

                        return pertenceAoEstado;
                    });

                    if (estadoMunicipios.length === 0) {
                        console.log('‚ùå Nenhum munic√≠pio encontrado para:', stateCode, stateName);
                        console.log('Propriedades dispon√≠veis no primeiro munic√≠pio:',
                            municipiosData.features[0]?.properties);
                        return;
                    }

                    console.log(`‚úÖ Encontrados ${estadoMunicipios.length} munic√≠pios para ${stateName}`);

                    // Remover layer de munic√≠pios anterior se existir
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    // Limpar labels antigos dos munic√≠pios
                    if (window.municipioLabels) {
                        window.municipioLabels.forEach(labelMarker => {
                            // Remover o marcador do label do mapa
                            if (labelMarker && map.hasLayer(labelMarker)) {
                                map.removeLayer(labelMarker);
                            }
                        });
                        window.municipioLabels = [];
                    }

                    // Criar layer dos munic√≠pios com cores por representante
                    municipiosLayer = L.geoJson(estadoMunicipios, {
                        style: feature => {
                            const municipioName = feature.properties.name || feature.properties.nome || feature.properties.municipio || feature.properties.description;
                            return getMunicipioStyleByRepresentative(municipioName);
                        },
                        onEachFeature: onEachMunicipioFeature,
                        interactive: true
                    }).addTo(map);

                    // Configurar a layer dos munic√≠pios para ter prioridade sobre os estados quando no modo munic√≠pios
                    municipiosLayer.setZIndex(15);

                    // For√ßar atualiza√ß√£o dos estilos para garantir que as cores estejam corretas
                    setTimeout(() => {
                        if (municipiosLayer) {
                            municipiosLayer.eachLayer(layer => {
                                const props = layer.feature.properties;
                                const municipioName = props.name || props.nome || props.municipio || props.description;
                                layer.setStyle(getMunicipioStyleByRepresentative(municipioName));
                            });
                        }
                    }, 100);

                    // N√£o mostrar legenda quando apenas o estado √© selecionado
                    // A legenda s√≥ aparecer√° quando um munic√≠pio espec√≠fico for clicado
                    updateLegend([]);

                    viewMode = 'municipios';
                    mainTitle.textContent = `Munic√≠pios de ${stateName || stateCode} - Clique em um munic√≠pio para ver os representantes`;
                    backButton.classList.remove('hidden');

                    // Se for S√£o Paulo, mostrar os bairros
                    if (stateCode === 'SP' || stateName === 'SAO PAULO') {
                        if (bairrosLayer) {
                            // Atualizar estilos dos bairros baseado no estado atual
                            updateBairrosStyles();
                            map.addLayer(bairrosLayer);
                            console.log('üèòÔ∏è Bairros de S√£o Paulo adicionados ao mapa');
                        }
                    } else {
                        // Se n√£o for SP, remover os bairros se estiverem vis√≠veis
                        if (bairrosLayer && map.hasLayer(bairrosLayer)) {
                            map.removeLayer(bairrosLayer);
                            console.log('üèòÔ∏è Bairros removidos do mapa (n√£o √© SP)');
                        }
                    }

                    console.log(`üéØ Modo munic√≠pios ativado para ${stateName}. Munic√≠pios carregados: ${estadoMunicipios.length}`);
                }

                // Fun√ß√£o para atualizar estilos da camada de bairros baseado no estado atual
                function updateBairrosStyles() {
                    if (!bairrosLayer) return;
                    
                    bairrosLayer.eachLayer(function(layer) {
                        const feature = layer.feature;
                        const bairroName = feature.properties.NOME_DIST;
                        
                        if (bairroName) {
                            const normalizedBairroName = normalize(bairroName);
                            
                            // IMPORTANTE: Buscar representantes considerando o estado atual (SP para bairros)
                            let representatives = [];
                            if (viewMode === 'municipios' && currentState && currentState.code === 'SP') {
                                // Para bairros de SP, usar a chave cidade+estado
                                const cidadeEstadoKey = `${normalizedBairroName}-SP`;
                                representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                                
                                // Se n√£o encontrar com chave composta, tentar s√≥ o nome (compatibilidade)
                                if (representatives.length === 0) {
                                    representatives = municipioRepresentativeMap.get(normalizedBairroName) || [];
                                }
                            }
                            
                            if (representatives.length > 0) {
                                // Se h√° representantes, usar a cor do primeiro representante
                                const firstRep = representatives[0];
                                const color = representativeColorMap.get(firstRep.id) || '#9CA3AF';

                                layer.setStyle({
                                    color: '#DC2626',        // Vermelho para o contorno
                                    weight: 3,
                                    opacity: 1,
                                    dashArray: '8,6',        // Pontilhado/dashed
                                    fillColor: color,
                                    fillOpacity: 0.7,
                                });
                            } else {
                                // Estilo padr√£o para bairros sem representantes
                                layer.setStyle({
                                    color: '#DC2626',        // Vermelho para o contorno
                                    weight: 2,
                                    opacity: 0.6,
                                    dashArray: '12,8',       // Mais pontilhado
                                    fillColor: '#f3f4f6',   // Cinza claro
                                    fillOpacity: 0.3,
                                });
                            }
                        }
                    });
                }

                function zoomToMunicipio(municipioName, stateName) {
                    // Primeiro, garantir que os munic√≠pios do estado est√£o carregados
                    const stateCode = getStateCodeByName(stateName);
                    if (!stateCode) return false;

                    // Encontrar e selecionar o estado primeiro
                    const stateFeature = geoJsonLayer.getLayers().find(layer => {
                        const props = layer.feature.properties;
                        const layerStateCode = getStateCode(props);
                        const layerStateName = props.nome || props.name || props.NAME;

                        return layerStateCode === stateCode ||
                            normalize(layerStateName) === normalize(stateName);
                    });

                    if (!stateFeature) {
                        console.log('Estado n√£o encontrado:', stateName, stateCode);
                        return false;
                    }

                    // Reset do estado anterior se existir
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                    }

                    // Remove munic√≠pios anteriores se existirem
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    // Reset do munic√≠pio selecionado
                    selectedMunicipioLayer = null;

                    // Seleciona o estado
                    selectedStateLayer = stateFeature;
                    selectedStateLayer.setStyle(selectedMapStyle);
                    currentState = { code: stateCode, name: stateName, layer: stateFeature };

                    // Filtrar munic√≠pios do estado
                    const estadoMunicipios = municipiosData.features.filter(feature => {
                        const props = feature.properties;
                        let municipioState = props.uf || props.estado || props.sigla_uf ||
                            props.UF || props.ESTADO || props.cd_geocuf;

                        // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                        if (!municipioState && props.uf_municipio) {
                            const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                            if (match) {
                                municipioState = match[1];
                            }
                        }

                        return municipioState === stateCode ||
                            municipioState === stateName ||
                            normalize(municipioState) === normalize(stateCode) ||
                            normalize(municipioState) === normalize(stateName);
                    });

                    if (estadoMunicipios.length === 0) {
                        console.log('Nenhum munic√≠pio encontrado para o estado:', stateName, stateCode);
                        return false;
                    }

                    // Encontrar o munic√≠pio espec√≠fico
                    const targetMunicipio = estadoMunicipios.find(feature => {
                        const props = feature.properties;
                        const name = props.name || props.nome || props.municipio || props.description;
                        return normalize(name) === normalize(municipioName);
                    });

                    if (!targetMunicipio) {
                        console.log('Munic√≠pio n√£o encontrado:', municipioName, 'no estado:', stateName);
                        // Mesmo assim, mostrar os munic√≠pios do estado
                        showMunicipios(stateCode, stateName, stateFeature);
                        return false;
                    }

                    // Criar layer com todos os munic√≠pios do estado
                    municipiosLayer = L.geoJson(estadoMunicipios, {
                        style: feature => {
                            const name = feature.properties.name || feature.properties.nome || feature.properties.municipio || feature.properties.description;
                            return getMunicipioStyleByRepresentative(name);
                        },
                        onEachFeature: onEachMunicipioFeature
                    }).addTo(map);

                    // Fazer zoom no munic√≠pio espec√≠fico
                    const municipioBounds = L.geoJson(targetMunicipio).getBounds();
                    map.fitBounds(municipioBounds, { padding: [50, 50] });

                    // Destacar o munic√≠pio
                    const municipioLayer = municipiosLayer.getLayers().find(layer => {
                        const props = layer.feature.properties;
                        const name = props.name || props.nome || props.municipio || props.description;
                        return normalize(name) === normalize(municipioName);
                    });

                    if (municipioLayer) {
                        selectedMunicipioLayer = municipioLayer;
                        selectedMunicipioLayer.setStyle(municipioSelectedStyle);
                    }

                    // Obter representantes do estado e atualizar legenda
                    const stateRepresentatives = representativesData.filter(rep =>
                        rep.SiglaEstado === stateCode ||
                        normalize(rep.Estado) === normalize(stateName)
                    );
                    updateLegend(stateRepresentatives);

                    viewMode = 'municipios';
                    mainTitle.textContent = `Munic√≠pio: ${municipioName} - ${stateName}`;
                    backButton.classList.remove('hidden');

                    return true;
                }

                function getStateCodeByName(stateName) {
                    const stateToAbbrev = {
                        'SAO PAULO': 'SP', 'RIO DE JANEIRO': 'RJ', 'MINAS GERAIS': 'MG', 'BAHIA': 'BA',
                        'PARANA': 'PR', 'RIO GRANDE DO SUL': 'RS', 'PERNAMBUCO': 'PE', 'CEARA': 'CE',
                        'PARA': 'PA', 'SANTA CATARINA': 'SC', 'GOIAS': 'GO', 'MARANHAO': 'MA',
                        'PARAIBA': 'PB', 'AMAZONAS': 'AM', 'ESPIRITO SANTO': 'ES', 'MATO GROSSO': 'MT',
                        'ALAGOAS': 'AL', 'PIAUI': 'PI', 'DISTRITO FEDERAL': 'DF', 'MATO GROSSO DO SUL': 'MS',
                        'SERGIPE': 'SE', 'RIO GRANDE DO NORTE': 'RN', 'RONDONIA': 'RO', 'ACRE': 'AC',
                        'AMAPA': 'AP', 'RORAIMA': 'RR', 'TOCANTINS': 'TO'
                    };

                    const normalizedStateName = normalize(stateName).toUpperCase();
                    const stateCode = stateToAbbrev[normalizedStateName];

                    console.log('üîç Convertendo nome do estado:', stateName, '->', normalizedStateName, '->', stateCode);

                    return stateCode || null;
                }

                // Fun√ß√£o para obter o estado de um munic√≠pio baseado nas propriedades do GeoJSON
                function getMunicipioState(props) {
                    // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio (formato: "UF - Munic√≠pio")
                    let municipioState = props.uf || props.estado || props.sigla_uf ||
                        props.UF || props.ESTADO || props.cd_geocuf;

                    // Se n√£o encontrou, tentar extrair do uf_municipio
                    if (!municipioState && props.uf_municipio) {
                        // Tentar diferentes formatos
                        // Formato: "UF - Munic√≠pio" (ex: "SP - S√£o Paulo")
                        let match = props.uf_municipio.match(/^([A-Z]{2})\s*-\s*/);
                        if (match) {
                            municipioState = match[1];
                        } else {
                            // Formato: "Estado - Munic√≠pio" (ex: "Rio Grande do Sul - Arroio do Tigre")
                            match = props.uf_municipio.match(/^([^-]+)\s*-\s*/);
                            if (match) {
                                const estadoNome = match[1].trim();
                                // Converter nome do estado para sigla
                                municipioState = getStateCodeByName(estadoNome);
                            }
                        }
                    }

                    console.log('üîç Propriedades do munic√≠pio:', props);
                    console.log('üîç Estado extra√≠do:', municipioState);

                    return municipioState;
                }

                // Fun√ß√£o para encontrar a layer de um estado pelo c√≥digo
                function findStateLayerByCode(stateCode) {
                    let targetLayer = null;
                    geoJsonLayer.eachLayer(layer => {
                        const layerStateCode = getStateCode(layer.feature.properties);
                        if (layerStateCode === stateCode) {
                            targetLayer = layer;
                        }
                    });
                    return targetLayer;
                }

                function onEachMunicipioFeature(feature, layer) {
                    const props = feature.properties;
                    const municipioName = props.name || props.nome || props.municipio || props.description;
                    const normalizedName = normalize(municipioName);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    // Buscar representantes considerando o estado atual apenas quando estamos visualizando munic√≠pios
                    let representatives = [];
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        const normalizedEstado = normalize(currentState.code);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                    } else {
                        // IMPORTANTE: N√£o fazer busca apenas por cidade para evitar conflitos
                        // Se n√£o temos estado espec√≠fico, n√£o podemos determinar qual cidade espec√≠fica
                        representatives = [];
                    }

                    layer.on({
                        mouseover: e => {
                            if (e.target !== selectedMunicipioLayer) {
                                e.target.setStyle(getMunicipioHighlightStyle(municipioName));
                            }
                        },
                        mouseout: e => {
                            if (e.target !== selectedMunicipioLayer) {
                                municipiosLayer.resetStyle(e.target);
                            }
                        }
                        // Removemos o click handler - ser√° tratado pelo listener global
                    });

                    // Tooltip com informa√ß√µes do munic√≠pio e representantes
                    let tooltipContent = `<strong>${municipioName}</strong>`;
                    if (representatives.length > 0) {
                        tooltipContent += `<br><small>Representantes: ${representatives.length}</small>`;
                        representatives.slice(0, 2).forEach(rep => {
                            const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                            tooltipContent += `<br><span style="color: ${color}; font-weight: bold;">‚Ä¢</span> ${rep.NomeRepresentante}`;
                        });
                        if (representatives.length > 2) {
                            tooltipContent += `<br>... e mais ${representatives.length - 2}`;
                        }
                    } else {
                        tooltipContent += `<br><small style="color: #6B7280;"></small>`;
                    }

                    layer.bindTooltip(tooltipContent, {
                        permanent: false,
                        direction: 'top',
                        className: 'municipio-tooltip'
                    });

                    // Adicionar label com nome do munic√≠pio centralizado
                    // addMunicipioLabel(layer, municipioName); // Labels removidos conforme solicitado
                }

                function filterByMunicipio(municipioName) {
                    console.log(`üîç Buscando representantes para o munic√≠pio: ${municipioName}`);
                    console.log(`üìç ViewMode: ${viewMode}, CurrentState:`, currentState);

                    // Usar o mapeamento normalizado para buscar representantes
                    const normalizedName = normalize(municipioName);
                    console.log(`üìç Nome normalizado: ${normalizedName}`);

                    // IMPORTANTE: Sempre usar cidade+estado para evitar conflitos
                    let representatives = [];
                    let estadoMunicipio = null;

                    // Se estamos em um estado espec√≠fico e visualizando munic√≠pios, usar cidade+estado
                    if (viewMode === 'municipios' && currentState && currentState.code) {
                        estadoMunicipio = currentState.code;
                        const normalizedEstado = normalize(estadoMunicipio);
                        const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                        representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                        console.log('üìç Buscando por cidade+estado (estado selecionado):', cidadeEstadoKey);
                    } else {
                        // NOVA L√ìGICA: Se n√£o temos estado selecionado, tentar determinar o estado do munic√≠pio
                        console.log('üîç Estado n√£o selecionado, tentando determinar estado do munic√≠pio...');
                        
                        // Buscar o munic√≠pio nos dados geogr√°ficos para determinar seu estado
                        if (municipiosData && municipiosData.features) {
                            const municipioFeature = municipiosData.features.find(feature => {
                                const props = feature.properties;
                                const name = props.name || props.nome || props.municipio || props.description;
                                return normalize(name) === normalizedName;
                            });

                            if (municipioFeature) {
                                const props = municipioFeature.properties;
                                // Extrair estado do uf_municipio (formato: "Estado - Cidade")
                                if (props.uf_municipio) {
                                    const ufMunicipio = props.uf_municipio.split(' - ')[0];
                                    // Converter nome do estado para sigla
                                    const stateToAbbrev = {
                                        'S√£o Paulo': 'SP', 'Rio de Janeiro': 'RJ', 'Minas Gerais': 'MG', 'Bahia': 'BA',
                                        'Paran√°': 'PR', 'Rio Grande do Sul': 'RS', 'Pernambuco': 'PE', 'Cear√°': 'CE',
                                        'Par√°': 'PA', 'Santa Catarina': 'SC', 'Goi√°s': 'GO', 'Maranh√£o': 'MA',
                                        'Para√≠ba': 'PB', 'Amazonas': 'AM', 'Esp√≠rito Santo': 'ES', 'Mato Grosso': 'MT',
                                        'Alagoas': 'AL', 'Piau√≠': 'PI', 'Distrito Federal': 'DF', 'Mato Grosso do Sul': 'MS',
                                        'Sergipe': 'SE', 'Rio Grande do Norte': 'RN', 'Rond√¥nia': 'RO', 'Acre': 'AC',
                                        'Amap√°': 'AP', 'Roraima': 'RR', 'Tocantins': 'TO'
                                    };
                                    estadoMunicipio = stateToAbbrev[ufMunicipio] || ufMunicipio;
                                    console.log(`üìç Estado do munic√≠pio determinado: ${ufMunicipio} -> ${estadoMunicipio}`);
                                }
                            }
                        }

                        if (estadoMunicipio) {
                            const normalizedEstado = normalize(estadoMunicipio);
                            const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                            representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                            console.log('üìç Buscando por cidade+estado (estado determinado):', cidadeEstadoKey);
                        } else {
                            console.log('‚ö†Ô∏è N√£o foi poss√≠vel determinar o estado do munic√≠pio');
                            representatives = [];
                        }
                    }

                    console.log('üìç Chaves dispon√≠veis no map:', Array.from(municipioRepresentativeMap.keys()).slice(0, 10));

                    console.log(`üìä Representantes encontrados inicialmente: ${representatives.length}`);
                    console.log('üìã Representantes:', representatives);

                    // Filtrar representantes que atendem especificamente este munic√≠pio
                    const filteredRepresentatives = representatives.filter(rep => {
                        if (rep.EstadosDetalhados) {
                            // Verificar se o munic√≠pio est√° em algum dos estados do representante
                            const atendeMunicipio = Object.entries(rep.EstadosDetalhados).some(([estado, dadosEstado]) => {
                                return dadosEstado.cidades && dadosEstado.cidades.some(cidade =>
                                    normalize(cidade) === normalizedName
                                );
                            });

                            if (atendeMunicipio) {
                                console.log(`‚úÖ ${rep.NomeRepresentante} atende ${municipioName}`);
                            }

                            return atendeMunicipio;
                        }
                        return true; // Se n√£o tem EstadosDetalhados, incluir todos
                    });

                    console.log(`üéØ Representantes finais para ${municipioName}: ${filteredRepresentatives.length}`);

                    renderResults(filteredRepresentatives, municipioName);
                    mainTitle.textContent = `Representantes em ${municipioName}`;

                    // Mostrar legenda com os representantes encontrados
                    updateLegend(filteredRepresentatives);

                    document.getElementById('results-container').scrollIntoView({ behavior: 'smooth' });
                }

                // --- L√ìGICA E RENDERIZA√á√ÉO ---

                function normalize(str) {
                    return (str || "")
                        .toString()
                        .normalize("NFD")
                        .replace(/[ÃÄ-ÕØ]/g, "")
                        .replace(/[^\w\s]/gi, "")
                        .replace(/\s+/g, " ")
                        .trim()
                        .toLowerCase();
                }

                function handleSearch() {
                    const query = searchInput.value.trim();

                    if (!query) {
                        resetView(false);
                        showInitialMessage();
                        hideSuggestions();
                        // Reset input state
                        searchInput.classList.remove('has-results', 'no-results', 'search-loading');
                        return;
                    }

                    // Adicionar estado de loading
                    searchInput.classList.add('search-loading');
                    searchInput.classList.remove('has-results', 'no-results');

                    // Adicionar ao hist√≥rico apenas se n√£o foi uma busca de sugest√£o
                    if (document.activeElement !== searchInput || !suggestionsContainer.classList.contains('hidden')) {
                        addToRecentSearches(query);
                    }
                    
                    hideSuggestions();

                    // Simular delay para mostrar loading (pode ser removido em produ√ß√£o)
                    setTimeout(() => {
                        const results = searchRepresentatives(query);
                        
                        // Remover loading e adicionar estado baseado nos resultados
                        searchInput.classList.remove('search-loading');
                        
                        if (results.length === 0) {
                            searchInput.classList.add('no-results');
                            renderResults([], query);
                        } else {
                            searchInput.classList.add('has-results');
                            renderResults(results, query);
                        }
                    }, 200); // Delay de 200ms para mostrar loading
                }

                function filterByState(stateCode) {
                    // N√£o mostrar cards de representantes ao clicar no estado
                    // Apenas mostrar os munic√≠pios coloridos
                    showInitialMessage();
                    mainTitle.textContent = `Munic√≠pios de ${stateCode} - Clique em um munic√≠pio para ver os representantes`;
                    backButton.classList.remove('hidden');
                    viewMode = 'municipios';
                }

                function renderResults(results, location = null) {
                    console.log(`üé® Renderizando ${results.length} resultados para: ${location}`);
                    console.log('üìã Resultados:', results);

                    if (!results.length) {
                        console.log('‚ùå Nenhum resultado para renderizar');
                        resultsContainer.innerHTML = `<div class="text-center text-gray-500 py-8">Nenhum representante encontrado${location ? ' para "' + location + '"' : ''}.</div>`;
                        return;
                    }

                    resultsContainer.innerHTML = results.map((item, index) => {
                        // Preparar informa√ß√µes dos estados
                        let estadosInfo = '';
                        if (item.EstadosDetalhados) {
                            const estadosArray = Object.entries(item.EstadosDetalhados).map(([estado, dados]) => {
                                const cidadesCount = dados.cidades ? dados.cidades.length : 0;
                                return `${estado} (${cidadesCount} cidades)`;
                            });
                            estadosInfo = estadosArray.join(', ');
                        } else {
                            estadosInfo = `${item.Estado} (${item.SiglaEstado})`;
                        }

                        // Separar telefones quando h√° mais de um
                        let telefonesHtml = '';
                        if (item.celular) {
                            const telefones = item.celular.split(/[\/\s]+/).filter(tel => tel.trim() && tel.trim() !== 'nan');
                            if (telefones.length > 0) {
                                if (telefones.length === 1) {
                                    // Um telefone: layout inline simples
                                    telefonesHtml = `<a href="tel:${telefones[0].trim()}" class="text-blue-600 underline" onclick="event.stopPropagation()">${telefones[0].trim()}</a>`;
                                } else if (telefones.length <= 3) {
                                    // 2-3 telefones: layout inline com separador
                                    telefonesHtml = `<div class="flex flex-wrap gap-1 items-center">
                                        ${telefones.map(tel => 
                                            `<a href="tel:${tel.trim()}" class="phone-pill" onclick="event.stopPropagation()">${tel.trim()}</a>`
                                        ).join('')}
                                    </div>`;
                                } else {
                                    // Muitos telefones: layout compacto com expans√£o
                                    const primeiros = telefones.slice(0, 2);
                                    const restantes = telefones.slice(2);
                                    telefonesHtml = `<div class="flex flex-wrap gap-1 items-center">
                                        ${primeiros.map(tel => 
                                            `<a href="tel:${tel.trim()}" class="phone-pill" onclick="event.stopPropagation()">${tel.trim()}</a>`
                                        ).join('')}
                                        <button class="phone-expand-btn text-xs px-2 py-1 rounded-full" 
                                                onclick="event.stopPropagation(); this.style.display='none'; this.nextElementSibling.style.display='flex';" 
                                                title="Ver mais ${restantes.length} telefones">
                                            +${restantes.length}
                                        </button>
                                        <div class="hidden flex-wrap gap-1 items-center">
                                            ${restantes.map(tel => 
                                                `<a href="tel:${tel.trim()}" class="phone-pill" onclick="event.stopPropagation()">${tel.trim()}</a>`
                                            ).join('')}
                                        </div>
                                    </div>`;
                                }
                            }
                        }

                        return `
                <div class="result-item bg-blue-50 rounded-lg p-4 shadow-sm cursor-pointer hover:bg-blue-100 transition-colors" 
                     data-representante-index="${index}" 
                     onclick="highlightRepresentanteAreas(${index})">
                    <div class="font-semibold text-blue-800 text-lg mb-2">${item.NomeRepresentante}</div>
                    ${item.CodigoRepresentante ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="id-card-lanyard" class="w-4 h-4"></i> ${item.CodigoRepresentante}</div>` : ''}
                    ${item.Contato ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="user" class="w-4 h-4"></i> ${item.Contato}</div>` : ''}
                    ${item.email ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="mail" class="w-4 h-4"></i> <a href="mailto:${item.email}" class="text-blue-600 underline" onclick="event.stopPropagation()">${item.email}</a></div>` : ''}
                    ${telefonesHtml ? `<div class="text-gray-700 text-sm mb-1"><div class="flex items-start gap-2"><i data-lucide="phone" class="w-4 h-4 mt-0.5 flex-shrink-0"></i> <div class="flex-1">${telefonesHtml}</div></div></div>` : ''}
                </div>
            `;
                    }).join('');

                    // Armazenar resultados globalmente para acesso nas fun√ß√µes de highlight
                    window.currentResults = results;

                    // Inicializar √≠cones da Lucide ap√≥s renderizar o conte√∫do
                    setTimeout(() => {
                        if (window.lucide) {
                            window.lucide.createIcons();
                        }
                    }, 100);
                }

                function showInitialMessage() {
                    resultsContainer.innerHTML = '<div class="text-center text-gray-500 py-8">Digite uma cidade ou estado para encontrar representantes, ou clique no mapa.</div>';
                }

                // Fun√ß√£o para alternar entre modo normal e maximizado do mapa
                function toggleMapMaximize() {
                    const container = document.getElementById('representantes-container');
                    const maximizeBtn = document.getElementById('maximize-map-btn');
                    const isMaximized = container.classList.contains('map-maximized');

                    if (isMaximized) {
                        // Restaurar modo normal
                        container.classList.remove('map-maximized');
                        document.body.classList.remove('map-fullscreen');
                        maximizeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                        </svg>
                    `;
                        maximizeBtn.title = 'Maximizar mapa';
                    } else {
                        // Maximizar mapa em tela cheia
                        container.classList.add('map-maximized');
                        document.body.classList.add('map-fullscreen');
                        maximizeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    `;
                        maximizeBtn.title = 'Restaurar mapa';
                    }

                    // For√ßar redimensionamento do mapa
                    setTimeout(() => {
                        if (map) {
                            map.invalidateSize();
                        }
                    }, 100);
                }

                // Fun√ß√£o para adicionar label com nome do munic√≠pio
                function addMunicipioLabel(layer, municipioName) {
                    // Fun√ß√£o desabilitada - labels removidos conforme solicitado
                    return;

                    // Obter o centro do munic√≠pio
                    const bounds = layer.getBounds();
                    const center = bounds.getCenter();

                    // Criar um div personalizado para o label fixo
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'municipio-label-fixo';
                    labelDiv.innerHTML = municipioName;
                    labelDiv.style.cssText = `
                    position: absolute;
                    background: transparent;
                    border: none;
                    border-radius: 0;
                    padding: 0;
                    font-size: 5px;
                    font-weight: 600;
                    color: #333;
                    text-align: center;
                    white-space: nowrap;
                    pointer-events: none;
                    z-index: 1000;
                    box-shadow: none;
                    transform: translate(-50%, -50%);
                `;

                    // Criar um elemento Leaflet para o label
                    const labelElement = L.divIcon({
                        html: labelDiv,
                        className: 'municipio-label-container',
                        iconSize: [1, 1],
                        iconAnchor: [0, 0]
                    });

                    // Criar um marcador para o label
                    const labelMarker = L.marker(center, {
                        icon: labelElement,
                        interactive: false
                    }).addTo(map);

                    // Armazenar refer√™ncia para poder remover depois se necess√°rio
                    if (!window.municipioLabels) {
                        window.municipioLabels = [];
                    }
                    window.municipioLabels.push(labelMarker);
                }



                // Fun√ß√£o para destacar √°reas atendidas por um representante
                function highlightRepresentanteAreas(index) {
                    if (!window.currentResults || !window.currentResults[index]) {
                        console.log('Representante n√£o encontrado no √≠ndice:', index);
                        return;
                    }

                    const representante = window.currentResults[index];
                    console.log('Destacando √°reas do representante:', representante.NomeRepresentante);

                    // Remover highlight anterior se existir
                    if (highlightedMunicipiosLayer) {
                        map.removeLayer(highlightedMunicipiosLayer);
                        highlightedMunicipiosLayer = null;
                    }

                    // Encontrar munic√≠pios atendidos pelo representante
                    const municipiosDestacados = [];

                    if (representante.EstadosDetalhados) {
                        // Nova estrutura: percorrer estados e suas cidades
                        Object.entries(representante.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                            // FILTRO: Se estivermos visualizando um estado espec√≠fico, mostrar apenas munic√≠pios deste estado
                            if (viewMode === 'municipios' && currentState && currentState.code && 
                                estado !== currentState.code && normalize(estado) !== normalize(currentState.code)) {
                                return; // Pular este estado se n√£o for o estado atual
                            }

                            if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                                dadosEstado.cidades.forEach(cidade => {
                                    const normalizedCidade = normalize(cidade);

                                    // IMPORTANTE: Buscar munic√≠pio considerando o estado para evitar conflitos
                                    const municipioFeature = municipiosData.features.find(feature => {
                                        const props = feature.properties;
                                        const municipioName = props.name || props.nome || props.municipio || props.description;
                                        const municipioState = props.uf || props.estado || props.sigla_uf || props.UF || props.ESTADO || props.cd_geocuf;

                                        // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                                        let extractedState = municipioState;
                                        if (!extractedState && props.uf_municipio) {
                                            const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                                            if (match) {
                                                extractedState = match[1];
                                            }
                                        }

                                        // Verificar se o munic√≠pio e estado correspondem
                                        return normalize(municipioName) === normalizedCidade &&
                                            (extractedState === estado || normalize(extractedState) === normalize(estado));
                                    });

                                    if (municipioFeature) {
                                        municipiosDestacados.push(municipioFeature);
                                    }
                                });
                            }
                        });
                    } else {
                        // Estrutura antiga: usar CidadesAtendidas
                        // FILTRO: Se estivermos visualizando um estado espec√≠fico, mostrar apenas munic√≠pios deste estado
                        if (viewMode === 'municipios' && currentState && currentState.code && 
                            representante.SiglaEstado !== currentState.code && 
                            normalize(representante.SiglaEstado) !== normalize(currentState.code)) {
                            // N√£o destacar munic√≠pios de outros estados quando estiver focado em um estado espec√≠fico
                            console.log(`Pulando representante ${representante.NomeRepresentante} do estado ${representante.SiglaEstado} pois estamos focados no estado ${currentState.code}`);
                        } else {
                            const cidadesAtendidas = representante.CidadesAtendidas || [];
                            cidadesAtendidas.forEach(cidade => {
                                const normalizedCidade = normalize(cidade);

                                // IMPORTANTE: Buscar munic√≠pio considerando o estado para evitar conflitos
                                const municipioFeature = municipiosData.features.find(feature => {
                                    const props = feature.properties;
                                    const municipioName = props.name || props.nome || props.municipio || props.description;
                                    const municipioState = props.uf || props.estado || props.sigla_uf || props.UF || props.ESTADO || props.cd_geocuf;

                                    // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                                    let extractedState = municipioState;
                                    if (!extractedState && props.uf_municipio) {
                                        const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                                        if (match) {
                                            extractedState = match[1];
                                        }
                                    }

                                    // Verificar se o munic√≠pio e estado correspondem
                                    return normalize(municipioName) === normalizedCidade &&
                                        (extractedState === representante.SiglaEstado || normalize(extractedState) === normalize(representante.SiglaEstado));
                                });

                                if (municipioFeature) {
                                    municipiosDestacados.push(municipioFeature);
                                }
                            });
                        }
                    }

                    if (municipiosDestacados.length === 0) {
                        console.log('Nenhum munic√≠pio encontrado no mapa para o representante:', representante.NomeRepresentante);
                        alert(`Nenhum munic√≠pio encontrado no mapa para ${representante.NomeRepresentante}`);
                        return;
                    }

                    console.log(`Encontrados ${municipiosDestacados.length} munic√≠pios para destacar`);

                    // Criar camada de destaque
                    const representanteColor = representativeColorMap.get(representante.id) || '#FF6B6B';

                    highlightedMunicipiosLayer = L.geoJson(municipiosDestacados, {
                        style: {
                            fillColor: representanteColor,
                            weight: 3,
                            opacity: 1,
                            color: '#FFFFFF',
                            dashArray: '5,5',
                            fillOpacity: 0.8
                        },
                        onEachFeature: function (feature, layer) {
                            const props = feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;

                            layer.bindTooltip(`
                            <strong>${municipioName}</strong><br>
                            <span style="color: ${representanteColor}; font-weight: bold;">‚óè</span> ${representante.NomeRepresentante}
                        `, {
                                permanent: false,
                                direction: 'top',
                                className: 'highlight-tooltip'
                            });
                        }
                    }).addTo(map);

                    // Fazer zoom para mostrar todos os munic√≠pios destacados
                    if (highlightedMunicipiosLayer.getBounds().isValid()) {
                        map.fitBounds(highlightedMunicipiosLayer.getBounds(), {
                            padding: [20, 20],
                            maxZoom: 8
                        });
                    }

                    // Destacar o card clicado
                    document.querySelectorAll('.result-item').forEach((card, i) => {
                        if (i === index) {
                            card.style.backgroundColor = representanteColor + '20'; // 20% opacity
                            card.style.borderLeft = `4px solid ${representanteColor}`;
                        } else {
                            card.style.backgroundColor = '';
                            card.style.borderLeft = '';
                        }
                    });

                    // Atualizar t√≠tulo
                    mainTitle.textContent = `√Åreas atendidas por ${representante.NomeRepresentante} (${municipiosDestacados.length} munic√≠pios)`;
                }

                function resetView(clearSearch = true) {
                    // Reset de todas as sele√ß√µes
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                        selectedStateLayer = null;
                    }

                    if (selectedMunicipioLayer) {
                        selectedMunicipioLayer = null;
                    }

                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    if (highlightedMunicipiosLayer) {
                        map.removeLayer(highlightedMunicipiosLayer);
                        highlightedMunicipiosLayer = null;
                    }

                    // Remover bairros quando voltar para visualiza√ß√£o geral
                    if (bairrosLayer && map.hasLayer(bairrosLayer)) {
                        map.removeLayer(bairrosLayer);
                        console.log('üèòÔ∏è Bairros removidos ao voltar para visualiza√ß√£o geral');
                    }



                    currentState = null;
                    viewMode = 'states';

                    map.setView([-15.78, -47.92], 4);
                    if (clearSearch) searchInput.value = '';
                    showInitialMessage();
                    backButton.classList.add('hidden');
                    mainTitle.textContent = 'Escolha sua regi√£o para encontrar representantes';

                    // Atualizar estilos dos munic√≠pios se ainda estiverem vis√≠veis
                    if (municipiosLayer) {
                        municipiosLayer.eachLayer(layer => {
                            const props = layer.feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            layer.setStyle(getMunicipioStyleByRepresentative(municipioName));
                        });
                    }

                    // Esconder legenda
                    updateLegend([]);

                    // Remove legenda de cores se existir
                    const existingLegend = document.getElementById('color-legend');
                    if (existingLegend) {
                        existingLegend.remove();
                    }

                    // Reset dos cards destacados
                    document.querySelectorAll('.result-item').forEach(card => {
                        card.style.backgroundColor = '';
                        card.style.borderLeft = '';
                    });
                }

                initializeApp();
            });
        </script>
</body>

</html>