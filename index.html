<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encontre Nossos Representantes</title>

    <!-- Depend√™ncias do Mapa (Leaflet.js) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Estiliza√ß√£o com Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>

    <style>
        /* Remover todos os outlines de focus */
        * {
            outline: none !important;
        }
        
        /* Remover focus espec√≠fico de bot√µes e inputs */
        button:focus,
        input:focus,
        select:focus,
        textarea:focus {
            outline: none !important;
            box-shadow: none !important;
        }
        
        body,
        html {
            height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            overflow-x: hidden;
        }

        #representantes-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .grid-container {
            flex: 1;
            display: grid;
            gap: 1rem;
            grid-template-columns: 1fr;
            min-height: 0;
        }

        @media (min-width: 1024px) {
            .grid-container {
                grid-template-columns: 3fr 2fr;
                gap: 2rem;
            }
        }

        .map-container {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .map-wrapper {
            flex: 1;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            padding: 1rem;
            position: relative;
            min-height: 300px;
        }

        #map {
            height: 100%;
            width: 100%;
            border-radius: 0.5rem;
            background-color: #fff;
            min-height: 300px;
        }

        @media (min-width: 768px) {
            #map {
                min-height: 400px;
            }
        }

        @media (min-width: 1024px) {
            #map {
                min-height: calc(100vh - 200px);
            }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .sidebar-content {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .results-container {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
            max-height: 400px;
        }

        @media (min-width: 1024px) {
            .results-container {
                max-height: calc(100vh - 300px);
            }
        }

        @media (max-height: 600px) {
            .results-container {
                max-height: 250px;
            }
            
            #map {
                min-height: 250px;
            }
        }

        /* Melhorias para dispositivos m√≥veis muito pequenos */
        @media (max-width: 480px) {
            #representantes-container {
                padding: 0.5rem;
            }
            
            .main-content {
                gap: 0.5rem;
            }
            
            .map-wrapper {
                padding: 0.5rem;
            }
            
            .sidebar-content {
                padding: 1rem;
            }
            
            .results-container {
                max-height: 300px;
            }
        }

        @media (max-width: 480px) and (max-height: 700px) {
            #map {
                min-height: 200px;
            }
            
            .results-container {
                max-height: 200px;
            }
        }

        /* Ajustes para orienta√ß√£o landscape em dispositivos m√≥veis */
        @media (max-height: 500px) and (orientation: landscape) {
            .grid-container {
                grid-template-columns: 1fr 1fr;
                gap: 0.5rem;
            }
            
            #map {
                min-height: 200px;
            }
            
            .results-container {
                max-height: 200px;
            }
            
            #representantes-container {
                padding: 0.5rem;
            }
        }

        .leaflet-interactive {
            transition: fill-opacity 0.2s ease-in-out;
        }

        .result-item {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* .municipio-tooltip {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 500;
        } */

        /* Bot√£o de Reset Zoom */
        .reset-zoom-btn {
            position: absolute;
            bottom: 10px;
            right: 50px;
            z-index: 1000;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reset-zoom-btn:hover {
            background: #f4f4f4;
            border-color: rgba(0, 0, 0, 0.4);
        }

        .reset-zoom-btn svg {
            width: 18px;
            height: 18px;
            color: #333;
        }

        /* Bot√£o de Maximizar Mapa */
        .maximize-map-btn {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .maximize-map-btn:hover {
            background: #f4f4f4;
            border-color: rgba(0, 0, 0, 0.4);
        }

        .maximize-map-btn svg {
            width: 18px;
            height: 18px;
            color: #333;
        }

        /* Estado maximizado */
        .map-maximized .grid-container {
            grid-template-columns: 1fr !important;
        }

        .map-maximized .sidebar {
            display: none !important;
        }

        .map-maximized .map-container {
            grid-column: 1 / -1;
        }

        .map-maximized .map-wrapper {
            min-height: calc(100vh - 100px) !important;
        }

        /* Labels dos munic√≠pios */
        .municipio-label-tooltip {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #000000 !important;
            font-size: 10px !important;
            font-weight: 600 !important;
            text-align: center !important;
            text-shadow: 
                -1px -1px 0 #ffffff,
                1px -1px 0 #ffffff,
                -1px 1px 0 #ffffff,
                1px 1px 0 #ffffff;
            white-space: nowrap !important;
            pointer-events: none !important;
            user-select: none !important;
            font-family: 'Inter', sans-serif !important;
            line-height: 1.2 !important;
            max-width: 120px !important;
            overflow: hidden !important;
            text-overflow: ellipsis !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        /* Ajustar tamanho do texto baseado no zoom */
        .leaflet-zoom-animated .municipio-label-tooltip {
            font-size: 11px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-6 .municipio-label-tooltip,
        .leaflet-zoom-animated.leaflet-zoom-level-7 .municipio-label-tooltip {
            font-size: 12px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-8 .municipio-label-tooltip,
        .leaflet-zoom-animated.leaflet-zoom-level-9 .municipio-label-tooltip {
            font-size: 13px !important;
        }

        .leaflet-zoom-animated.leaflet-zoom-level-10 .municipio-label-tooltip {
            font-size: 14px !important;
        }

    </style>

</head>

<body class="bg-gray-50">

    <div id="representantes-container" class="container mx-auto p-2 sm:p-4 lg:p-6 max-w-7xl">

        <div class="mb-4 lg:mb-6">
            <h1 id="main-title" class="text-xl sm:text-2xl lg:text-3xl font-bold text-gray-800">Escolha sua regi√£o para encontrar
                representantes</h1>
            <button id="back-to-brazil" class="hidden text-blue-600 font-semibold mt-2 hover:underline">&lt; VOLTAR PARA
                O MAPA DO BRASIL</button>
        </div>

        <div class="main-content">
            <div class="grid-container">

                <!-- Coluna do Mapa -->
                <div class="map-container">
                    <div class="map-wrapper">
                        <div id="map"></div>
                        <button id="reset-zoom-btn" class="reset-zoom-btn" title="Resetar zoom">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" />
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z" />
                            </svg>
                        </button>
                        
                        <button id="maximize-map-btn" class="maximize-map-btn" title="Maximizar mapa">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                                stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round"
                                    d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Coluna de Busca e Resultados -->
                <div class="sidebar">
                    <div class="sidebar-content">
                        <h2 class="text-lg sm:text-xl font-bold text-gray-800 mb-4">SEUS REPRESENTANTES</h2>

                        <div class="mb-4">
                            <input type="text" id="search-input" placeholder="Digite o nome, estado ou cidade"
                                class="w-full px-3 py-2 sm:px-4 sm:py-3 border border-gray-300 rounded-lg outline-none transition text-sm sm:text-base">
                        </div>

                        <div id="results-container" class="results-container space-y-3 pr-2">
                        <div id="initial-message" class="text-center py-16">
                            <div id="loading-indicator">
                                <svg class="animate-spin mx-auto h-12 w-12 text-blue-600"
                                    xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                        stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor"
                                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                    </path>
                                </svg>
                                <p class="mt-4 text-sm text-gray-500">Carregando dados...</p>
                            </div>
                            <div id="default-message" class="hidden">
                                <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg"
                                    fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round"
                                        d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m5.231 13.481L15 17.25m-4.5-15H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Zm3.75 11.625a2.625 2.625 0 1 1-5.25 0 2.625 2.625 0 0 1 5.25 0Z" />
                                </svg>
                                <p class="mt-4 text-sm text-gray-500">Use a busca ou clique em um estado no mapa.</p>
                            </div>
                        </div>
                        
                        <!-- Legenda de Representantes -->
                        <div id="legend" class="legend hidden mt-4 p-3 bg-white rounded-lg border border-gray-200">
                            <h3 class="text-sm font-semibold text-gray-700 mb-2">Legenda de Cores</h3>
                            <div id="legend-items" class="space-y-1 max-h-32 overflow-y-auto"></div>
                            <div class="mt-2 pt-2 border-t border-gray-200">
                                <div class="flex items-center text-xs text-gray-600">
                                    <div class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                                    <span>Sem representante</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            // --- CONFIGURA√á√ÉO ---
            const jsonFileUrl = './data/representantes_por_estado.json';
            const municipiosJsonUrl = 'https://raw.githubusercontent.com/screamonei2/mapa-brasil-representantes/main/old/geojs-100-mun-v2.json';

            // URL do GeoJSON dos estados do Brasil
            const brazilStatesGeoJsonUrl = './data/uf.json';

            // --- VARI√ÅVEIS GLOBAIS ---
            let representativesData = [];
            let representativesByLocation = new Map();
            let municipiosData = [];
            let map;
            let geoJsonLayer;
            let municipiosLayer = null;
            let selectedStateLayer = null;
            let selectedMunicipioLayer = null;
            let currentState = null;
            let viewMode = 'states'; // 'states' ou 'municipios'
            let municipioRepresentativeMap = new Map(); // Mapa munic√≠pio -> representantes
            let representativeColorMap = new Map(); // Mapa representante -> cor
            let highlightedMunicipiosLayer = null; // Camada para destacar munic√≠pios do representante
            
            // Paleta de cores para representantes (azul padr√£o como primeira cor para SCHIOPPA)
            const representativeColors = [
                '#3b82f6', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
                '#A3E4D7', '#F9E79F', '#D5A6BD', '#AED6F1', '#A9DFBF',
                '#FAD7A0', '#D2B4DE', '#AED6F1', '#A9CCE3', '#D5DBDB',
                '#FADBD8', '#D6EAF8', '#D1F2EB', '#FCF3CF', '#EBDEF0'
            ];
            
            // Mapa espec√≠fico de cores para representantes especiais
            const specialRepresentativeColors = {
                'schioppa': '#3b82f6'  // Azul padr√£o para SCHIOPPA
            };

            const searchInput = document.getElementById('search-input');
            const resultsContainer = document.getElementById('results-container');
            const initialMessage = document.getElementById('initial-message');
            const loadingIndicator = document.getElementById('loading-indicator');
            const defaultMessage = document.getElementById('default-message');
            const backButton = document.getElementById('back-to-brazil');
            const mainTitle = document.getElementById('main-title');

            // --- FUN√á√ïES DE TRANSFORMA√á√ÉO DE DADOS ---

            function transformRepresentativesData(rawData) {
                console.log('üîÑ Transformando dados dos representantes...');
                const representativesMap = new Map();
                const locationMap = new Map();
                let colorIndex = 0;

                const stateToAbbrev = {
                    'SAO PAULO': 'SP', 'RIO DE JANEIRO': 'RJ', 'MINAS GERAIS': 'MG', 'BAHIA': 'BA',
                    'PARANA': 'PR', 'RIO GRANDE DO SUL': 'RS', 'PERNAMBUCO': 'PE', 'CEARA': 'CE',
                    'PARA': 'PA', 'SANTA CATARINA': 'SC', 'GOIAS': 'GO', 'MARANHAO': 'MA',
                    'PARAIBA': 'PB', 'AMAZONAS': 'AM', 'ESPIRITO SANTO': 'ES', 'MATO GROSSO': 'MT',
                    'ALAGOAS': 'AL', 'PIAUI': 'PI', 'DISTRITO FEDERAL': 'DF', 'MATO GROSSO DO SUL': 'MS',
                    'SERGIPE': 'SE', 'RIO GRANDE DO NORTE': 'RN', 'RONDONIA': 'RO', 'ACRE': 'AC',
                    'AMAPA': 'AP', 'RORAIMA': 'RR', 'TOCANTINS': 'TO'
                };

                // Verificar se os dados est√£o no formato esperado
                console.log('üìä Estrutura dos dados recebidos:', Object.keys(rawData));
                
                // Verificar se existe a propriedade 'representantes'
                const dadosRepresentantes = rawData.representantes || rawData;
                
                for (const [nomeEmpresa, dadosEmpresa] of Object.entries(dadosRepresentantes)) {
                    // Nova estrutura: dadosEmpresa.estados √© um objeto com estados como chaves
                    const codigo = dadosEmpresa.codigo || Math.random().toString();
                    const nome = dadosEmpresa.nome || nomeEmpresa;
                    const contato = dadosEmpresa.contato || {};
                    
                    // Nova estrutura: estados √© um objeto, n√£o um array
                    const estados = dadosEmpresa.estados || {};
                    
                    // Coletar todas as cidades de todos os estados
                    const todasCidades = [];
                    const todosEstados = [];
                    
                    for (const [estado, dadosEstado] of Object.entries(estados)) {
                        todosEstados.push(estado);
                        if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                            todasCidades.push(...dadosEstado.cidades);
                        }
                    }

                    // Determinar estado principal (primeiro estado ou 'DESCONHECIDO')
                    const estadoPrincipal = todosEstados.length > 0 ? todosEstados[0].trim() : 'DESCONHECIDO';
                    const siglaEstado = stateToAbbrev[estadoPrincipal] || estadoPrincipal.substring(0, 2);

                    const representante = {
                        id: `${nomeEmpresa}_${codigo}`,
                        NomeRepresentante: nome,
                        Contato: contato.nome_contato || '',
                        email: contato.email || '',
                        celular: contato.celular || '',
                        SiglaEstado: siglaEstado,
                        Estado: estadoPrincipal,
                        CidadesAtendidas: todasCidades,
                        CodigoRepresentante: codigo,
                        // Adicionar dados dos estados para uso posterior
                        EstadosDetalhados: estados
                    };

                    representativesMap.set(representante.id, representante);

                    // Atribuir cor ao representante
                    if (!representativeColorMap.has(representante.id)) {
                        // Verificar se √© um representante especial com cor espec√≠fica
                        const nomeNormalizado = nomeEmpresa.toLowerCase();
                        if (specialRepresentativeColors[nomeNormalizado]) {
                            representativeColorMap.set(representante.id, specialRepresentativeColors[nomeNormalizado]);
                        } else {
                            representativeColorMap.set(representante.id, representativeColors[colorIndex % representativeColors.length]);
                            colorIndex++;
                        }
                    }

                    // Indexar por estado
                    todosEstados.forEach(estado => {
                        const sigla = stateToAbbrev[estado] || estado.substring(0, 2);
                        [estado, sigla].forEach(key => {
                            if (!locationMap.has(key)) locationMap.set(key, new Set());
                            locationMap.get(key).add(representante.id);
                        });
                    });

                    // Indexar por cada cidade e criar mapeamento munic√≠pio-representante
                    // Nova estrutura: cidade+estado -> representante
                    for (const [estado, dadosEstado] of Object.entries(estados)) {
                        if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                            dadosEstado.cidades.forEach(cidade => {
                                const normalizedCidade = normalize(cidade);
                                const normalizedEstado = normalize(estado);
                                const cidadeEstadoKey = `${normalizedCidade}-${normalizedEstado}`;
                                
                                if (!locationMap.has(cidade)) locationMap.set(cidade, new Set());
                                locationMap.get(cidade).add(representante.id);
                                
                                // Mapear munic√≠pio+estado para representante (objeto completo)
                                if (!municipioRepresentativeMap.has(cidadeEstadoKey)) {
                                    municipioRepresentativeMap.set(cidadeEstadoKey, []);
                                }
                                municipioRepresentativeMap.get(cidadeEstadoKey).push(representante);
                                
                                // Tamb√©m manter o mapeamento apenas por cidade para compatibilidade
                                if (!municipioRepresentativeMap.has(normalizedCidade)) {
                                    municipioRepresentativeMap.set(normalizedCidade, []);
                                }
                                municipioRepresentativeMap.get(normalizedCidade).push(representante);
                            });
                        }
                    }
                }

                representativesByLocation = locationMap;
                
                console.log(`‚úÖ Transforma√ß√£o conclu√≠da:`);
                console.log(`üìä Total de representantes: ${representativesMap.size}`);
                console.log(`üìä Total de localiza√ß√µes: ${locationMap.size}`);
                console.log(`üìä Total de mapeamentos munic√≠pio-representante: ${municipioRepresentativeMap.size}`);
                console.log(`üìã Primeiras 5 chaves do municipioRepresentativeMap:`, Array.from(municipioRepresentativeMap.keys()).slice(0, 5));
                
                return Array.from(representativesMap.values());
            }

            // --- FUN√á√ÉO ESPECIAL PARA SCHIOPPA ---
            
            function mapSchioppaToAllMunicipios() {
                // Estados que a SCHIOPPA atende
                const estadosSchioppa = ['SE', 'RR', 'RN', 'AL', 'RO', 'MA', 'AP', 'AC'];
                
                // Encontrar o representante SCHIOPPA
                const schioppaRep = representativesData.find(rep => 
                    rep.nomeEmpresa && rep.nomeEmpresa.toLowerCase().includes('schioppa')
                );
                
                if (!schioppaRep) {
                    console.log('SCHIOPPA n√£o encontrada nos dados');
                    return;
                }
                
                console.log('Mapeando SCHIOPPA para todos os munic√≠pios dos estados:', estadosSchioppa);
                
                // Percorrer todos os munic√≠pios e mapear os dos estados da SCHIOPPA
                if (municipiosData && municipiosData.features) {
                    let municipiosMapeados = 0;
                    
                    municipiosData.features.forEach(feature => {
                        const props = feature.properties;
                        let ufMunicipio = '';
                        
                        // Extrair UF do munic√≠pio (diferentes formatos poss√≠veis)
                        if (props.uf_municipio) {
                            // Formato: "UF - Munic√≠pio"
                            ufMunicipio = props.uf_municipio.split(' - ')[0];
                        } else if (props.uf) {
                            ufMunicipio = props.uf;
                        } else if (props.estado) {
                            ufMunicipio = props.estado;
                        }
                        
                        // Se o munic√≠pio pertence a um estado da SCHIOPPA
                        if (estadosSchioppa.includes(ufMunicipio)) {
                            const nomeMunicipio = props.nome || props.name || props.municipio || '';
                            const normalizedName = normalize(nomeMunicipio);
                            
                                                            if (normalizedName) {
                                    // Adicionar SCHIOPPA ao mapeamento deste munic√≠pio
                                    const cidadeEstadoKey = `${normalizedName}-${ufMunicipio.toLowerCase()}`;
                                    
                                    if (!municipioRepresentativeMap.has(cidadeEstadoKey)) {
                                        municipioRepresentativeMap.set(cidadeEstadoKey, []);
                                    }
                                    
                                    // Verificar se SCHIOPPA j√° est√° mapeada para este munic√≠pio
                                    const existingReps = municipioRepresentativeMap.get(cidadeEstadoKey);
                                    const jaExiste = existingReps.some(rep => rep.id === schioppaRep.id);
                                    
                                    if (!jaExiste) {
                                        municipioRepresentativeMap.get(cidadeEstadoKey).push(schioppaRep);
                                        municipiosMapeados++;
                                    }
                                    
                                    // Tamb√©m manter o mapeamento apenas por cidade para compatibilidade
                                    if (!municipioRepresentativeMap.has(normalizedName)) {
                                        municipioRepresentativeMap.set(normalizedName, []);
                                    }
                                    
                                    const existingRepsCidade = municipioRepresentativeMap.get(normalizedName);
                                    const jaExisteCidade = existingRepsCidade.some(rep => rep.id === schioppaRep.id);
                                    
                                    if (!jaExisteCidade) {
                                        municipioRepresentativeMap.get(normalizedName).push(schioppaRep);
                                    }
                                }
                        }
                    });
                    
                    console.log(`SCHIOPPA mapeada para ${municipiosMapeados} munic√≠pios`);
                } else {
                    console.log('Dados de munic√≠pios n√£o dispon√≠veis para mapeamento da SCHIOPPA');
                }
            }

            // --- FUN√á√ïES DE BUSCA ---

            function searchRepresentatives(query) {
                if (!query) return [];

                const normalizedQuery = normalize(query);
                const foundRepresentativeIds = new Set();

                for (const [location, repIds] of representativesByLocation.entries()) {
                    if (normalize(location).includes(normalizedQuery)) {
                        repIds.forEach(id => foundRepresentativeIds.add(id));
                    }
                }

                representativesData.forEach(rep => {
                    if (normalize(rep.NomeRepresentante).includes(normalizedQuery) ||
                        normalize(rep.Contato).includes(normalizedQuery) ||
                        normalize(rep.email).includes(normalizedQuery)) {
                        foundRepresentativeIds.add(rep.id);
                    }
                });

                return representativesData.filter(rep => foundRepresentativeIds.has(rep.id));
            }

            function getRepresentativesByLocation(location) {
                const repIds = representativesByLocation.get(location) || new Set();
                return representativesData.filter(rep => repIds.has(rep.id));
            }

            // --- FUN√á√ïES DE INICIALIZA√á√ÉO ---

            async function initializeApp() {
                try {
                    const [rawRepData, rawMunicipiosData] = await Promise.all([
                        fetchJsonData(jsonFileUrl),
                        fetchJsonData(municipiosJsonUrl)
                    ]);

                    representativesData = transformRepresentativesData(rawRepData);
                    municipiosData = rawMunicipiosData;
                    
                    // Mapear SCHIOPPA para todos os munic√≠pios dos seus estados
                    mapSchioppaToAllMunicipios();

                    // Debug: Verificar estrutura dos dados de munic√≠pios
                    if (municipiosData.features && municipiosData.features.length > 0) {
                        console.log('Estrutura do primeiro munic√≠pio:', municipiosData.features[0].properties);
                        console.log('Total de munic√≠pios carregados:', municipiosData.features.length);
                        console.log('Propriedades dispon√≠veis:', Object.keys(municipiosData.features[0].properties));
                    }

                    await setupMap();
                    setupEventListeners();
                    loadingIndicator.classList.add('hidden');
                    defaultMessage.classList.remove('hidden');
                } catch (error) {
                    console.error("Erro ao inicializar a aplica√ß√£o:", error);
                    initialMessage.innerHTML = `<p class="text-red-500 text-center">Falha ao carregar os dados. Verifique a conex√£o.</p>`;
                }
            }

            async function fetchJsonData(url) {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`N√£o foi poss√≠vel buscar o arquivo: ${response.statusText}`);
                return await response.json();
            }

            async function setupMap() {
                map = L.map('map', { zoomControl: true, attributionControl: false }).setView([-15.78, -47.92], 4);

                const response = await fetch(brazilStatesGeoJsonUrl);
                const brazilGeoJson = await response.json();

                geoJsonLayer = L.geoJson(brazilGeoJson, {
                    style: defaultMapStyle,
                    onEachFeature: onEachStateFeature,
                    interactive: true
                }).addTo(map);
                
                // Configurar a layer dos estados para ter prioridade
                geoJsonLayer.setZIndex(10);

                // Adicionar listener global no mapa para interceptar cliques
                map.on('click', handleGlobalMapClick);

                map.fitBounds(geoJsonLayer.getBounds());
            }

            function handleGlobalMapClick(e) {
                const latlng = e.latlng;
                console.log('Clique global detectado em:', latlng);
                
                // Fun√ß√£o para verificar se um ponto est√° dentro de um pol√≠gono (ray casting)
                function pointInPolygon(point, polygon) {
                    const x = point.lat, y = point.lng;
                    let inside = false;
                    
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        const xi = polygon[i].lat, yi = polygon[i].lng;
                        const xj = polygon[j].lat, yj = polygon[j].lng;
                        
                        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                            inside = !inside;
                        }
                    }
                    return inside;
                }
                
                // Se estamos no modo munic√≠pios, verificar munic√≠pios PRIMEIRO
                if (municipiosLayer && viewMode === 'municipios') {
                    console.log('üîç Verificando munic√≠pios primeiro (modo munic√≠pios ativo)');
                    let clickedMunicipio = null;
                    municipiosLayer.eachLayer(layer => {
                        if (layer.getBounds().contains(latlng)) {
                            const feature = layer.feature;
                            if (feature.geometry.type === 'Polygon') {
                                const coords = feature.geometry.coordinates[0].map(coord => ({lat: coord[1], lng: coord[0]}));
                                if (pointInPolygon(latlng, coords)) {
                                    clickedMunicipio = layer;
                                }
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                for (let polygon of feature.geometry.coordinates) {
                                    const coords = polygon[0].map(coord => ({lat: coord[1], lng: coord[0]}));
                                    if (pointInPolygon(latlng, coords)) {
                                        clickedMunicipio = layer;
                                        break;
                                    }
                                }
                            }
                        }
                    });
                    
                    if (clickedMunicipio) {
                        const props = clickedMunicipio.feature.properties;
                        const municipioName = props.name || props.nome || props.municipio || props.description;
                        if (municipioName) {
                            console.log('‚úÖ Clique interceptado em MUNIC√çPIO:', municipioName);
                            console.log('üìç Estado atual:', currentState);
                            console.log('üìç ViewMode:', viewMode);
                            
                            // Verificar a qual estado o munic√≠pio pertence
                            const municipioState = getMunicipioState(props);
                            console.log('üìç Estado do munic√≠pio:', municipioState);
                            
                            // Se o munic√≠pio pertence a um estado diferente do atual
                            if (currentState && municipioState && municipioState !== currentState.code) {
                                console.log('üîÑ Munic√≠pio pertence a estado diferente. Carregando novo estado...');
                                
                                // Encontrar o estado correto no mapa
                                const targetStateLayer = findStateLayerByCode(municipioState);
                                if (targetStateLayer) {
                                    console.log('üîÑ Carregando estado:', municipioState);
                                    const fakeEvent = {
                                        target: targetStateLayer,
                                        latlng: latlng,
                                        originalEvent: e.originalEvent
                                    };
                                    handleStateClick(fakeEvent);
                                    return;
                                }
                            }
                            
                            // Reset do munic√≠pio selecionado anterior
                            if (selectedMunicipioLayer) {
                                municipiosLayer.resetStyle(selectedMunicipioLayer);
                            }
                            
                            // Selecionar o novo munic√≠pio
                            selectedMunicipioLayer = clickedMunicipio;
                            selectedMunicipioLayer.setStyle(municipioSelectedStyle);
                            
                            // Mostrar os representantes do munic√≠pio
                            filterByMunicipio(municipioName);
                            
                            // Scroll para os resultados
                            document.getElementById('results-container').scrollIntoView({ behavior: 'smooth' });
                            return; // Parar aqui, n√£o processar estado
                        }
                    } else {
                        console.log('‚ùå Nenhum munic√≠pio encontrado no clique - verificando se √© clique em estado diferente');
                        
                        // Se n√£o encontrou munic√≠pio, verificar se √© clique em estado diferente
                        let clickedState = null;
                        geoJsonLayer.eachLayer(layer => {
                            if (layer.getBounds().contains(latlng)) {
                                const feature = layer.feature;
                                if (feature.geometry.type === 'Polygon') {
                                    const coords = feature.geometry.coordinates[0].map(coord => ({lat: coord[1], lng: coord[0]}));
                                    if (pointInPolygon(latlng, coords)) {
                                        clickedState = layer;
                                    }
                                } else if (feature.geometry.type === 'MultiPolygon') {
                                    for (let polygon of feature.geometry.coordinates) {
                                        const coords = polygon[0].map(coord => ({lat: coord[1], lng: coord[0]}));
                                        if (pointInPolygon(latlng, coords)) {
                                            clickedState = layer;
                                            break;
                                        }
                                    }
                                }
                            }
                        });
                        
                        if (clickedState) {
                            const clickedStateCode = getStateCode(clickedState.feature.properties);
                            const clickedStateName = clickedState.feature.properties.nome || clickedState.feature.properties.name || clickedState.feature.properties.NAME;
                            
                            // Verificar se √© um estado diferente do atual
                            if (currentState && currentState.code !== clickedStateCode) {
                                console.log('üîÑ Clique em estado diferente detectado:', clickedStateName, '(', clickedStateCode, ')');
                                console.log('üîÑ Estado atual:', currentState.name, '(', currentState.code, ')');
                                
                                // Fazer reset completo e carregar novo estado
                                const fakeEvent = {
                                    target: clickedState,
                                    latlng: latlng,
                                    originalEvent: e.originalEvent
                                };
                                handleStateClick(fakeEvent);
                                return;
                            }
                        }
                    }
                }
                
                // Se n√£o clicou em munic√≠pio ou n√£o estamos no modo munic√≠pios, verificar estados
                console.log('üîç Verificando estados...');
                let clickedState = null;
                geoJsonLayer.eachLayer(layer => {
                    if (layer.getBounds().contains(latlng)) {
                        // Verifica√ß√£o mais precisa usando geometria
                        const feature = layer.feature;
                        if (feature.geometry.type === 'Polygon') {
                            const coords = feature.geometry.coordinates[0].map(coord => ({lat: coord[1], lng: coord[0]}));
                            if (pointInPolygon(latlng, coords)) {
                                clickedState = layer;
                            }
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            for (let polygon of feature.geometry.coordinates) {
                                const coords = polygon[0].map(coord => ({lat: coord[1], lng: coord[0]}));
                                if (pointInPolygon(latlng, coords)) {
                                    clickedState = layer;
                                    break;
                                }
                            }
                        }
                    }
                });
                
                // Se clicou em um estado, processar como estado
                if (clickedState) {
                    console.log('‚úÖ Clique interceptado em ESTADO');
                    
                    // Verificar se √© um clique em um estado diferente do atual
                    const clickedStateCode = getStateCode(clickedState.feature.properties);
                    const clickedStateName = clickedState.feature.properties.nome || clickedState.feature.properties.name || clickedState.feature.properties.NAME;
                    
                    if (currentState && currentState.code !== clickedStateCode) {
                        console.log('üîÑ Clique em estado diferente detectado. Fazendo reset completo...');
                        // √â um clique em um estado diferente - fazer reset completo
                        const fakeEvent = {
                            target: clickedState,
                            latlng: latlng,
                            originalEvent: e.originalEvent
                        };
                        handleStateClick(fakeEvent);
                    } else if (!currentState) {
                        // Primeiro clique em um estado
                        const fakeEvent = {
                            target: clickedState,
                            latlng: latlng,
                            originalEvent: e.originalEvent
                        };
                        handleStateClick(fakeEvent);
                    }
                }
            }

            function setupEventListeners() {
                let debounceTimeout;
                searchInput.addEventListener('input', function () {
                    clearTimeout(debounceTimeout);
                    debounceTimeout = setTimeout(handleSearch, 300);
                });
                backButton.addEventListener('click', resetView);

                // Event listener para o bot√£o de reset zoom
                const resetZoomBtn = document.getElementById('reset-zoom-btn');
                resetZoomBtn.addEventListener('click', function () {
                    resetView(false); // false para n√£o limpar a busca
                });

                // Event listener para o bot√£o de maximizar mapa
                const maximizeMapBtn = document.getElementById('maximize-map-btn');
                maximizeMapBtn.addEventListener('click', function () {
                    toggleMapMaximize();
                });
            }

            // --- ESTILOS DO MAPA ---

            const defaultMapStyle = { fillColor: "#3b82f6", weight: 1, opacity: 1, color: 'white', fillOpacity: 0.7 };
            const highlightMapStyle = { weight: 0, color: '#fbbf24', fillOpacity: 0.9 };
            const selectedMapStyle = { fillColor: "#fbbf24", fillOpacity: 1 };
            const municipioSelectedStyle = { fillColor: "#fbbf24", weight: 2, opacity: 1, color: '#f59e0b', fillOpacity: 0.9 };

            // Fun√ß√£o para obter estilo do munic√≠pio baseado no representante
            function getMunicipioStyleByRepresentative(municipioName) {
                const normalizedName = normalize(municipioName);
                
                // Buscar representantes considerando o estado atual apenas quando estamos visualizando munic√≠pios
                let representatives = [];
                if (viewMode === 'municipios' && currentState && currentState.code) {
                    const normalizedEstado = normalize(currentState.code);
                    const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                    representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                } else {
                    // Busca geral - usar apenas cidade
                    representatives = municipioRepresentativeMap.get(normalizedName) || [];
                }
                
                if (representatives.length === 0) {
                    // Munic√≠pio sem representante - cor cinza
                    return {
                        fillColor: "#3b82f6",
                        weight: 1,
                        opacity: 1,
                        color: 'white',
                        fillOpacity: 0.6
                    };
                }
                
                // Se h√° m√∫ltiplos representantes, usar a cor do primeiro
                const primaryRepresentative = representatives[0];
                const color = representativeColorMap.get(primaryRepresentative.id) || '#3b82f6';
                
                return {
                    fillColor: color,
                    weight: 1,
                    opacity: 1,
                    color: 'white',
                    fillOpacity: representatives.length > 1 ? 0.8 : 0.6 // Mais opaco se m√∫ltiplos representantes
                };
            }
            
            // Fun√ß√£o para obter estilo de destaque do munic√≠pio
            function getMunicipioHighlightStyle(municipioName) {
                const normalizedName = normalize(municipioName);
                
                // Buscar representantes considerando o estado atual apenas quando estamos visualizando munic√≠pios
                let representatives = [];
                if (viewMode === 'municipios' && currentState && currentState.code) {
                    const normalizedEstado = normalize(currentState.code);
                    const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                    representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                } else {
                    // Busca geral - usar apenas cidade
                    representatives = municipioRepresentativeMap.get(normalizedName) || [];
                }
                
                if (representatives.length === 0) {
                    return { weight: 0, color: '#3b82f6', fillOpacity: 0.8 };
                }
                
                const primaryRepresentative = representatives[0];
                const color = representativeColorMap.get(primaryRepresentative.id) || '#3b82f6';
                
                return {
                    weight: 0,
                    color: color,
                    fillOpacity: 0.9
                };
            }
            
            // Fun√ß√£o para criar/atualizar a legenda
            function updateLegend(stateRepresentatives = []) {
                const legendElement = document.getElementById('legend');
                const legendItemsElement = document.getElementById('legend-items');
                
                if (!legendElement || !legendItemsElement) return;
                
                // Limpar itens existentes
                legendItemsElement.innerHTML = '';
                
                if (stateRepresentatives.length === 0) {
                    legendElement.classList.add('hidden');
                    return;
                }
                
                // Criar itens da legenda
                stateRepresentatives.forEach(rep => {
                    const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                    const legendItem = document.createElement('div');
                    legendItem.className = 'flex items-center text-xs text-gray-700';
                    legendItem.innerHTML = `
                        <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${color};"></div>
                        <span class="truncate" title="${rep.NomeRepresentante}">${rep.NomeRepresentante}</span>
                    `;
                    legendItemsElement.appendChild(legendItem);
                });
                
                legendElement.classList.remove('hidden');
            }

            // --- FUN√á√ïES DO MAPA DE ESTADOS ---

            function getStateCode(properties) {
                // Baseado na estrutura real do uf.json
                // Priorizar UF_05 que cont√©m a sigla do estado (ex: "CE", "AC", "BA")
                return properties.UF_05 || properties.uf || properties.sigla ||
                    properties.SIGLA || properties.UF ||
                    // Fallback para nome completo se n√£o encontrar sigla
                    properties.NOME_UF || properties.nome || properties.NOME ||
                    properties.name || properties.NAME;
            }

            function onEachStateFeature(feature, layer) {
                layer.on({
                    mouseover: e => {
                        if (e.target !== selectedStateLayer && viewMode === 'states') {
                            e.target.setStyle(highlightMapStyle);
                        }
                    },
                    mouseout: e => {
                        if (e.target !== selectedStateLayer && viewMode === 'states') {
                            geoJsonLayer.resetStyle(e.target);
                        }
                    }
                    // Removemos o click handler - ser√° tratado pelo listener global
                });
            }

            function handleStateClick(e) {
                const properties = e.target.feature.properties;
                let stateCode = getStateCode(properties);
                let stateName = properties.nome || properties.name || properties.NAME;

                console.log('üéØ Estado selecionado:', stateName, stateCode);

                // Reset completo ANTES de qualquer opera√ß√£o
                // Reset do estado anterior se existir
                if (selectedStateLayer) {
                    geoJsonLayer.resetStyle(selectedStateLayer);
                }

                // Remove munic√≠pios anteriores se existirem
                if (municipiosLayer) {
                    map.removeLayer(municipiosLayer);
                    municipiosLayer = null;
                }

                // Reset do munic√≠pio selecionado
                selectedMunicipioLayer = null;

                // Limpar resultados e legenda
                showInitialMessage();
                updateLegend([]);

                // Seleciona o novo estado
                selectedStateLayer = e.target;
                selectedStateLayer.setStyle(selectedMapStyle);
                currentState = { code: stateCode, name: stateName, layer: e.target };

                // Aplicar zoom no estado
                const stateBounds = e.target.getBounds();
                console.log('üîç Aplicando zoom no estado:', stateName, 'Bounds:', stateBounds);
                
                map.fitBounds(stateBounds, { 
                    padding: [25, 25],
                    maxZoom: 8  // Limitar zoom m√°ximo para n√£o ficar muito pr√≥ximo
                });

                // Aguardar um pouco para garantir que o zoom seja aplicado antes de carregar munic√≠pios
                setTimeout(() => {
                    // Mostra munic√≠pios e filtra representantes ap√≥s o zoom
                    showMunicipios(stateCode, stateName, e.target);
                    filterByState(stateCode);
                }, 300); // 300ms de delay para garantir
            }

            // Filtrar munic√≠pios apenas do estado selecionado
            function showMunicipios(stateCode, stateName, stateLayer) {
                console.log(`üîç Carregando munic√≠pios para o estado: ${stateName} (${stateCode})`);
                
                // Filtrar munic√≠pios do estado usando m√∫ltiplos crit√©rios
                const estadoMunicipios = municipiosData.features.filter(feature => {
                    const props = feature.properties;

                    // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio (formato: "UF - Munic√≠pio")
                    let municipioState = props.uf || props.estado || props.sigla_uf ||
                        props.UF || props.ESTADO || props.cd_geocuf;
                    
                    // Se n√£o encontrou, tentar extrair do uf_municipio
                    if (!municipioState && props.uf_municipio) {
                        const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                        if (match) {
                            municipioState = match[1];
                        }
                    }

                    // Comparar com c√≥digo e nome do estado
                    const pertenceAoEstado = municipioState === stateCode ||
                        municipioState === stateName ||
                        normalize(municipioState) === normalize(stateCode) ||
                        normalize(municipioState) === normalize(stateName);
                    
                    if (pertenceAoEstado) {
                        const municipioName = props.name || props.nome || props.municipio || props.description;
                        console.log(`‚úÖ Munic√≠pio ${municipioName} pertence ao estado ${stateName}`);
                    }
                    
                    return pertenceAoEstado;
                });

                if (estadoMunicipios.length === 0) {
                    console.log('‚ùå Nenhum munic√≠pio encontrado para:', stateCode, stateName);
                    console.log('Propriedades dispon√≠veis no primeiro munic√≠pio:',
                        municipiosData.features[0]?.properties);
                    return;
                }

                console.log(`‚úÖ Encontrados ${estadoMunicipios.length} munic√≠pios para ${stateName}`);

                // Remover layer de munic√≠pios anterior se existir
                if (municipiosLayer) {
                    map.removeLayer(municipiosLayer);
                    municipiosLayer = null;
                }

                // Limpar labels antigos dos munic√≠pios
                if (window.municipioLabels) {
                    window.municipioLabels.forEach(layer => {
                        // Remover tooltip permanente se existir
                        if (layer.getTooltip()) {
                            layer.unbindTooltip();
                        }
                    });
                    window.municipioLabels = [];
                }

                // Criar layer dos munic√≠pios com cores por representante
                municipiosLayer = L.geoJson(estadoMunicipios, {
                    style: feature => {
                        const municipioName = feature.properties.name || feature.properties.nome || feature.properties.municipio || feature.properties.description;
                        return getMunicipioStyleByRepresentative(municipioName);
                    },
                    onEachFeature: onEachMunicipioFeature,
                    interactive: true
                }).addTo(map);
                
                // Configurar a layer dos munic√≠pios para ter prioridade sobre os estados quando no modo munic√≠pios
                municipiosLayer.setZIndex(15);
                
                // For√ßar atualiza√ß√£o dos estilos para garantir que as cores estejam corretas
                setTimeout(() => {
                    if (municipiosLayer) {
                        municipiosLayer.eachLayer(layer => {
                            const props = layer.feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            layer.setStyle(getMunicipioStyleByRepresentative(municipioName));
                        });
                    }
                }, 100);

                // N√£o mostrar legenda quando apenas o estado √© selecionado
                // A legenda s√≥ aparecer√° quando um munic√≠pio espec√≠fico for clicado
                updateLegend([]);

                viewMode = 'municipios';
                mainTitle.textContent = `Munic√≠pios de ${stateName || stateCode} - Clique em um munic√≠pio para ver os representantes`;
                backButton.classList.remove('hidden');
                
                console.log(`üéØ Modo munic√≠pios ativado para ${stateName}. Munic√≠pios carregados: ${estadoMunicipios.length}`);
            }

            function zoomToMunicipio(municipioName, stateName) {
                // Primeiro, garantir que os munic√≠pios do estado est√£o carregados
                const stateCode = getStateCodeByName(stateName);
                if (!stateCode) return false;

                // Encontrar e selecionar o estado primeiro
                const stateFeature = geoJsonLayer.getLayers().find(layer => {
                    const props = layer.feature.properties;
                    const layerStateCode = getStateCode(props);
                    const layerStateName = props.nome || props.name || props.NAME;

                    return layerStateCode === stateCode ||
                        normalize(layerStateName) === normalize(stateName);
                });

                if (!stateFeature) {
                    console.log('Estado n√£o encontrado:', stateName, stateCode);
                    return false;
                }

                // Reset do estado anterior se existir
                if (selectedStateLayer) {
                    geoJsonLayer.resetStyle(selectedStateLayer);
                }

                // Remove munic√≠pios anteriores se existirem
                if (municipiosLayer) {
                    map.removeLayer(municipiosLayer);
                    municipiosLayer = null;
                }

                // Reset do munic√≠pio selecionado
                selectedMunicipioLayer = null;

                // Seleciona o estado
                selectedStateLayer = stateFeature;
                selectedStateLayer.setStyle(selectedMapStyle);
                currentState = { code: stateCode, name: stateName, layer: stateFeature };

                // Filtrar munic√≠pios do estado
                const estadoMunicipios = municipiosData.features.filter(feature => {
                    const props = feature.properties;
                    let municipioState = props.uf || props.estado || props.sigla_uf ||
                        props.UF || props.ESTADO || props.cd_geocuf;
                    
                    // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio
                    if (!municipioState && props.uf_municipio) {
                        const match = props.uf_municipio.match(/^([A-Z]{2})\s*-/);
                        if (match) {
                            municipioState = match[1];
                        }
                    }

                    return municipioState === stateCode ||
                        municipioState === stateName ||
                        normalize(municipioState) === normalize(stateCode) ||
                        normalize(municipioState) === normalize(stateName);
                });

                if (estadoMunicipios.length === 0) {
                    console.log('Nenhum munic√≠pio encontrado para o estado:', stateName, stateCode);
                    return false;
                }

                // Encontrar o munic√≠pio espec√≠fico
                const targetMunicipio = estadoMunicipios.find(feature => {
                    const props = feature.properties;
                    const name = props.name || props.nome || props.municipio || props.description;
                    return normalize(name) === normalize(municipioName);
                });

                if (!targetMunicipio) {
                    console.log('Munic√≠pio n√£o encontrado:', municipioName, 'no estado:', stateName);
                    // Mesmo assim, mostrar os munic√≠pios do estado
                    showMunicipios(stateCode, stateName, stateFeature);
                    return false;
                }

                // Criar layer com todos os munic√≠pios do estado
                municipiosLayer = L.geoJson(estadoMunicipios, {
                    style: feature => {
                        const name = feature.properties.name || feature.properties.nome || feature.properties.municipio || feature.properties.description;
                        return getMunicipioStyleByRepresentative(name);
                    },
                    onEachFeature: onEachMunicipioFeature
                }).addTo(map);

                // Fazer zoom no munic√≠pio espec√≠fico
                const municipioBounds = L.geoJson(targetMunicipio).getBounds();
                map.fitBounds(municipioBounds, { padding: [50, 50] });

                // Destacar o munic√≠pio
                const municipioLayer = municipiosLayer.getLayers().find(layer => {
                    const props = layer.feature.properties;
                    const name = props.name || props.nome || props.municipio || props.description;
                    return normalize(name) === normalize(municipioName);
                });

                if (municipioLayer) {
                    selectedMunicipioLayer = municipioLayer;
                    selectedMunicipioLayer.setStyle(municipioSelectedStyle);
                }

                // Obter representantes do estado e atualizar legenda
                const stateRepresentatives = representativesData.filter(rep => 
                    rep.SiglaEstado === stateCode || 
                    normalize(rep.Estado) === normalize(stateName)
                );
                updateLegend(stateRepresentatives);

                viewMode = 'municipios';
                mainTitle.textContent = `Munic√≠pio: ${municipioName} - ${stateName}`;
                backButton.classList.remove('hidden');

                return true;
            }

            function getStateCodeByName(stateName) {
                const stateToAbbrev = {
                    'SAO PAULO': 'SP', 'RIO DE JANEIRO': 'RJ', 'MINAS GERAIS': 'MG', 'BAHIA': 'BA',
                    'PARANA': 'PR', 'RIO GRANDE DO SUL': 'RS', 'PERNAMBUCO': 'PE', 'CEARA': 'CE',
                    'PARA': 'PA', 'SANTA CATARINA': 'SC', 'GOIAS': 'GO', 'MARANHAO': 'MA',
                    'PARAIBA': 'PB', 'AMAZONAS': 'AM', 'ESPIRITO SANTO': 'ES', 'MATO GROSSO': 'MT',
                    'ALAGOAS': 'AL', 'PIAUI': 'PI', 'DISTRITO FEDERAL': 'DF', 'MATO GROSSO DO SUL': 'MS',
                    'SERGIPE': 'SE', 'RIO GRANDE DO NORTE': 'RN', 'RONDONIA': 'RO', 'ACRE': 'AC',
                    'AMAPA': 'AP', 'RORAIMA': 'RR', 'TOCANTINS': 'TO'
                };

                const normalizedStateName = normalize(stateName).toUpperCase();
                const stateCode = stateToAbbrev[normalizedStateName];
                
                console.log('üîç Convertendo nome do estado:', stateName, '->', normalizedStateName, '->', stateCode);
                
                return stateCode || null;
            }

            // Fun√ß√£o para obter o estado de um munic√≠pio baseado nas propriedades do GeoJSON
            function getMunicipioState(props) {
                // Para geojs-100-mun-v2.json, extrair UF do campo uf_municipio (formato: "UF - Munic√≠pio")
                let municipioState = props.uf || props.estado || props.sigla_uf ||
                    props.UF || props.ESTADO || props.cd_geocuf;
                
                // Se n√£o encontrou, tentar extrair do uf_municipio
                if (!municipioState && props.uf_municipio) {
                    // Tentar diferentes formatos
                    // Formato: "UF - Munic√≠pio" (ex: "SP - S√£o Paulo")
                    let match = props.uf_municipio.match(/^([A-Z]{2})\s*-\s*/);
                    if (match) {
                        municipioState = match[1];
                    } else {
                        // Formato: "Estado - Munic√≠pio" (ex: "Rio Grande do Sul - Arroio do Tigre")
                        match = props.uf_municipio.match(/^([^-]+)\s*-\s*/);
                        if (match) {
                            const estadoNome = match[1].trim();
                            // Converter nome do estado para sigla
                            municipioState = getStateCodeByName(estadoNome);
                        }
                    }
                }

                console.log('üîç Propriedades do munic√≠pio:', props);
                console.log('üîç Estado extra√≠do:', municipioState);
                
                return municipioState;
            }

            // Fun√ß√£o para encontrar a layer de um estado pelo c√≥digo
            function findStateLayerByCode(stateCode) {
                let targetLayer = null;
                geoJsonLayer.eachLayer(layer => {
                    const layerStateCode = getStateCode(layer.feature.properties);
                    if (layerStateCode === stateCode) {
                        targetLayer = layer;
                    }
                });
                return targetLayer;
            }

            function onEachMunicipioFeature(feature, layer) {
                const props = feature.properties;
                const municipioName = props.name || props.nome || props.municipio || props.description;
                const normalizedName = normalize(municipioName);
                
                // Buscar representantes considerando o estado atual apenas quando estamos visualizando munic√≠pios
                let representatives = [];
                if (viewMode === 'municipios' && currentState && currentState.code) {
                    const normalizedEstado = normalize(currentState.code);
                    const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                    representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                } else {
                    // Busca geral - usar apenas cidade
                    representatives = municipioRepresentativeMap.get(normalizedName) || [];
                }

                layer.on({
                    mouseover: e => {
                        if (e.target !== selectedMunicipioLayer) {
                            e.target.setStyle(getMunicipioHighlightStyle(municipioName));
                        }
                    },
                    mouseout: e => {
                        if (e.target !== selectedMunicipioLayer) {
                            municipiosLayer.resetStyle(e.target);
                        }
                    }
                    // Removemos o click handler - ser√° tratado pelo listener global
                });

                // Tooltip com informa√ß√µes do munic√≠pio e representantes
                let tooltipContent = `<strong>${municipioName}</strong>`;
                if (representatives.length > 0) {
                    tooltipContent += `<br><small>Representantes: ${representatives.length}</small>`;
                    representatives.slice(0, 2).forEach(rep => {
                        const color = representativeColorMap.get(rep.id) || '#9CA3AF';
                        tooltipContent += `<br><span style="color: ${color}; font-weight: bold;">‚Ä¢</span> ${rep.NomeRepresentante}`;
                    });
                    if (representatives.length > 2) {
                        tooltipContent += `<br>... e mais ${representatives.length - 2}`;
                    }
                } else {
                    tooltipContent += `<br><small style="color: #6B7280;"></small>`;
                }

                layer.bindTooltip(tooltipContent, {
                    permanent: false,
                    direction: 'top',
                    className: 'municipio-tooltip'
                });

                // Adicionar label com nome do munic√≠pio centralizado
                addMunicipioLabel(layer, municipioName);
            }

            function filterByMunicipio(municipioName) {
                console.log(`üîç Buscando representantes para o munic√≠pio: ${municipioName}`);
                console.log(`üìç ViewMode: ${viewMode}, CurrentState:`, currentState);
                
                // Usar o mapeamento normalizado para buscar representantes
                const normalizedName = normalize(municipioName);
                console.log(`üìç Nome normalizado: ${normalizedName}`);
                
                // Se estamos em um estado espec√≠fico e visualizando munic√≠pios, usar cidade+estado
                let representatives = [];
                if (viewMode === 'municipios' && currentState && currentState.code) {
                    const normalizedEstado = normalize(currentState.code);
                    const cidadeEstadoKey = `${normalizedName}-${normalizedEstado}`;
                    representatives = municipioRepresentativeMap.get(cidadeEstadoKey) || [];
                    console.log('üìç Buscando por cidade+estado:', cidadeEstadoKey);
                    console.log('üìç Chaves dispon√≠veis no map:', Array.from(municipioRepresentativeMap.keys()).slice(0, 10));
                } else {
                    // Busca geral - usar apenas cidade
                    representatives = municipioRepresentativeMap.get(normalizedName) || [];
                    console.log('üìç Buscando apenas por cidade:', normalizedName);
                }
                
                console.log(`üìä Representantes encontrados inicialmente: ${representatives.length}`);
                console.log('üìã Representantes:', representatives);
                
                // Filtrar representantes que atendem especificamente este munic√≠pio
                const filteredRepresentatives = representatives.filter(rep => {
                    if (rep.EstadosDetalhados) {
                        // Verificar se o munic√≠pio est√° em algum dos estados do representante
                        const atendeMunicipio = Object.entries(rep.EstadosDetalhados).some(([estado, dadosEstado]) => {
                            return dadosEstado.cidades && dadosEstado.cidades.some(cidade => 
                                normalize(cidade) === normalizedName
                            );
                        });
                        
                        if (atendeMunicipio) {
                            console.log(`‚úÖ ${rep.NomeRepresentante} atende ${municipioName}`);
                        }
                        
                        return atendeMunicipio;
                    }
                    return true; // Se n√£o tem EstadosDetalhados, incluir todos
                });
                
                console.log(`üéØ Representantes finais para ${municipioName}: ${filteredRepresentatives.length}`);
                
                renderResults(filteredRepresentatives, municipioName);
                mainTitle.textContent = `Representantes em ${municipioName}`;
                
                // Mostrar legenda com os representantes encontrados
                updateLegend(filteredRepresentatives);
                
                document.getElementById('results-container').scrollIntoView({ behavior: 'smooth' });
            }

            // --- L√ìGICA E RENDERIZA√á√ÉO ---

            function normalize(str) {
                return (str || "")
                    .toString()
                    .normalize("NFD")
                    .replace(/[ÃÄ-ÕØ]/g, "")
                    .replace(/[^\w\s]/gi, "")
                    .replace(/\s+/g, " ")
                    .trim()
                    .toLowerCase();
            }

            function handleSearch() {
                const query = searchInput.value.trim();

                if (!query) {
                    resetView(false);
                    showInitialMessage();
                    return;
                }

                const results = searchRepresentatives(query);

                if (results.length === 0) {
                    renderResults([], query);
                    return;
                }

                renderResults(results, query);

                // L√≥gica de zoom baseada no tipo de busca
                const normalizedQuery = normalize(query);

                // 1. Verificar se √© busca por estado (sigla ou nome)
                let foundState = null;

                // Buscar por sigla de estado
                for (const rep of results) {
                    if (normalize(rep.SiglaEstado) === normalizedQuery ||
                        normalize(rep.Estado) === normalizedQuery) {
                        foundState = { code: rep.SiglaEstado, name: rep.Estado };
                        break;
                    }
                }

                if (foundState) {
                    // √â uma busca por estado - simular clique no estado
                    const stateFeature = geoJsonLayer.getLayers().find(layer => {
                        const props = layer.feature.properties;
                        const stateCode = getStateCode(props);
                        const stateName = props.nome || props.name || props.NAME;

                        return stateCode === foundState.code ||
                            normalize(stateName) === normalize(foundState.name);
                    });

                    if (stateFeature) {
                        // Reset anterior
                        if (selectedStateLayer) {
                            geoJsonLayer.resetStyle(selectedStateLayer);
                        }
                        if (municipiosLayer) {
                            map.removeLayer(municipiosLayer);
                            municipiosLayer = null;
                        }

                        // Selecionar estado
                        selectedStateLayer = stateFeature;
                        selectedStateLayer.setStyle(selectedMapStyle);
                        currentState = foundState;
                        currentState.layer = stateFeature;

                        // Mostrar munic√≠pios
                        showMunicipios(foundState.code, foundState.name, stateFeature);
                        return;
                    }
                }

                // 2. Verificar se √© busca por munic√≠pio espec√≠fico
                // Buscar em todas as cidades atendidas de todos os representantes
                let foundMunicipio = null;
                let municipioState = null;
                
                for (const rep of results) {
                    const exactMatch = rep.CidadesAtendidas.find(cidade =>
                        normalize(cidade) === normalizedQuery
                    );
                    
                    if (exactMatch) {
                        foundMunicipio = exactMatch;
                        municipioState = rep.Estado;
                        break;
                    }
                }
                
                // Se n√£o encontrou match exato, buscar por match parcial
                if (!foundMunicipio) {
                    for (const rep of results) {
                        const partialMatch = rep.CidadesAtendidas.find(cidade =>
                            normalize(cidade).includes(normalizedQuery) && 
                            normalize(cidade).startsWith(normalizedQuery)
                        );
                        
                        if (partialMatch) {
                            foundMunicipio = partialMatch;
                            municipioState = rep.Estado;
                            break;
                        }
                    }
                }
                
                if (foundMunicipio && municipioState) {
                    // √â uma busca por munic√≠pio espec√≠fico
                    const success = zoomToMunicipio(foundMunicipio, municipioState);
                    if (success) {
                        // Filtrar resultados para mostrar apenas representantes deste munic√≠pio
                        filterByMunicipio(foundMunicipio);
                        return;
                    }
                }

                // 3. Fallback - zoom no primeiro estado dos resultados
                const fallbackState = { code: firstResult.SiglaEstado, name: firstResult.Estado };
                const stateFeature = geoJsonLayer.getLayers().find(layer => {
                    const props = layer.feature.properties;
                    const stateCode = getStateCode(props);

                    return stateCode === fallbackState.code;
                });

                if (stateFeature) {
                    if (selectedStateLayer) {
                        geoJsonLayer.resetStyle(selectedStateLayer);
                    }
                    if (municipiosLayer) {
                        map.removeLayer(municipiosLayer);
                        municipiosLayer = null;
                    }

                    selectedStateLayer = stateFeature;
                    selectedStateLayer.setStyle(selectedMapStyle);
                    currentState = fallbackState;
                    currentState.layer = stateFeature;

                    showMunicipios(fallbackState.code, fallbackState.name, stateFeature);
                }
            }

            function filterByState(stateCode) {
                // N√£o mostrar cards de representantes ao clicar no estado
                // Apenas mostrar os munic√≠pios coloridos
                showInitialMessage();
                mainTitle.textContent = `Munic√≠pios de ${stateCode} - Clique em um munic√≠pio para ver os representantes`;
                backButton.classList.remove('hidden');
                viewMode = 'municipios';
            }

            function zoomToLocation(estado, cidade) {
                if (cidade && estado) {
                    fetch(`https://nominatim.openstreetmap.org/search?city=${encodeURIComponent(cidade)}&state=${encodeURIComponent(estado)}&country=Brasil&format=json&limit=1`)
                        .then(res => res.json())
                        .then(data => {
                            if (data.length > 0) {
                                map.setView([parseFloat(data[0].lat), parseFloat(data[0].lon)], 11);
                            }
                        })
                        .catch(err => console.log('Erro ao buscar coordenadas:', err));
                }
            }



            function renderResults(results, location = null) {
                console.log(`üé® Renderizando ${results.length} resultados para: ${location}`);
                console.log('üìã Resultados:', results);
                
                if (!results.length) {
                    console.log('‚ùå Nenhum resultado para renderizar');
                    resultsContainer.innerHTML = `<div class="text-center text-gray-500 py-8">Nenhum representante encontrado${location ? ' para "' + location + '"' : ''}.</div>`;
                    return;
                }

                resultsContainer.innerHTML = results.map((item, index) => {
                    // Preparar informa√ß√µes dos estados
                    let estadosInfo = '';
                    if (item.EstadosDetalhados) {
                        const estadosArray = Object.entries(item.EstadosDetalhados).map(([estado, dados]) => {
                            const cidadesCount = dados.cidades ? dados.cidades.length : 0;
                            return `${estado} (${cidadesCount} cidades)`;
                        });
                        estadosInfo = estadosArray.join(', ');
                    } else {
                        estadosInfo = `${item.Estado} (${item.SiglaEstado})`;
                    }

                    // Separar telefones quando h√° mais de um
                    let telefonesHtml = '';
                    if (item.celular) {
                        const telefones = item.celular.split(/[\/\s]+/).filter(tel => tel.trim() && tel.trim() !== 'nan');
                        if (telefones.length > 0) {
                            telefonesHtml = telefones.map(tel => 
                                `<a href="tel:${tel.trim()}" class="text-blue-600 underline block" onclick="event.stopPropagation()">${tel.trim()}</a>`
                            ).join('');
                        }
                    }

                    return `
                <div class="result-item bg-blue-50 rounded-lg p-4 shadow-sm cursor-pointer hover:bg-blue-100 transition-colors" 
                     data-representante-index="${index}" 
                     onclick="highlightRepresentanteAreas(${index})">
                    <div class="font-semibold text-blue-800 text-lg mb-2">${item.NomeRepresentante}</div>
                    ${item.CodigoRepresentante ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="hash" class="w-4 h-4"></i><span class="font-medium">C√≥digo:</span> ${item.CodigoRepresentante}</div>` : ''}
                    ${item.Contato ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="user" class="w-4 h-4"></i><span class="font-medium">Contato:</span> ${item.Contato}</div>` : ''}
                    ${item.email ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="mail" class="w-4 h-4"></i><span class="font-medium">E-mail:</span> <a href="mailto:${item.email}" class="text-blue-600 underline" onclick="event.stopPropagation()">${item.email}</a></div>` : ''}
                    ${telefonesHtml ? `<div class="text-gray-700 text-sm mb-1 flex items-center gap-2"><i data-lucide="phone" class="w-4 h-4"></i><span class="font-medium">Telefones:</span> ${telefonesHtml}</div>` : ''}
                </div>
            `;
                }).join('');
                
                // Armazenar resultados globalmente para acesso nas fun√ß√µes de highlight
                window.currentResults = results;
                
                // Inicializar √≠cones da Lucide ap√≥s renderizar o conte√∫do
                setTimeout(() => {
                    if (window.lucide) {
                        window.lucide.createIcons();
                    }
                }, 100);
            }

            function showInitialMessage() {
                resultsContainer.innerHTML = '<div class="text-center text-gray-500 py-8">Digite uma cidade ou estado para encontrar representantes, ou clique no mapa.</div>';
            }

            // Fun√ß√£o para alternar entre modo normal e maximizado do mapa
            function toggleMapMaximize() {
                const container = document.getElementById('representantes-container');
                const maximizeBtn = document.getElementById('maximize-map-btn');
                const isMaximized = container.classList.contains('map-maximized');
                
                if (isMaximized) {
                    // Restaurar modo normal
                    container.classList.remove('map-maximized');
                    maximizeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                        </svg>
                    `;
                    maximizeBtn.title = 'Maximizar mapa';
                } else {
                    // Maximizar mapa
                    container.classList.add('map-maximized');
                    maximizeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"
                            stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round"
                                d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                        </svg>
                    `;
                    maximizeBtn.title = 'Restaurar mapa';
                }
                
                // For√ßar redimensionamento do mapa
                setTimeout(() => {
                    if (map) {
                        map.invalidateSize();
                    }
                }, 100);
            }

            // Fun√ß√£o para adicionar label com nome do munic√≠pio
            function addMunicipioLabel(layer, municipioName) {
                // Obter o centro do munic√≠pio
                const bounds = layer.getBounds();
                const center = bounds.getCenter();
                
                // Criar o label usando L.tooltip permanente
                layer.bindTooltip(municipioName, {
                    permanent: true,
                    direction: 'center',
                    className: 'municipio-label-tooltip',
                    offset: [0, 0]
                });
                
                // Armazenar refer√™ncia para poder remover depois se necess√°rio
                if (!window.municipioLabels) {
                    window.municipioLabels = [];
                }
                window.municipioLabels.push(layer);
            }

            // Fun√ß√£o para destacar √°reas atendidas por um representante
            function highlightRepresentanteAreas(index) {
                if (!window.currentResults || !window.currentResults[index]) {
                    console.log('Representante n√£o encontrado no √≠ndice:', index);
                    return;
                }

                const representante = window.currentResults[index];
                console.log('Destacando √°reas do representante:', representante.NomeRepresentante);

                // Remover highlight anterior se existir
                if (highlightedMunicipiosLayer) {
                    map.removeLayer(highlightedMunicipiosLayer);
                    highlightedMunicipiosLayer = null;
                }

                // Encontrar munic√≠pios atendidos pelo representante
                const municipiosDestacados = [];

                if (representante.EstadosDetalhados) {
                    // Nova estrutura: percorrer estados e suas cidades
                    Object.entries(representante.EstadosDetalhados).forEach(([estado, dadosEstado]) => {
                        if (dadosEstado.cidades && Array.isArray(dadosEstado.cidades)) {
                            dadosEstado.cidades.forEach(cidade => {
                                const normalizedCidade = normalize(cidade);
                                
                                // Buscar munic√≠pio no GeoJSON
                                const municipioFeature = municipiosData.features.find(feature => {
                                    const props = feature.properties;
                                    const municipioName = props.name || props.nome || props.municipio || props.description;
                                    return normalize(municipioName) === normalizedCidade;
                                });

                                if (municipioFeature) {
                                    municipiosDestacados.push(municipioFeature);
                                }
                            });
                        }
                    });
                } else {
                    // Estrutura antiga: usar CidadesAtendidas
                    const cidadesAtendidas = representante.CidadesAtendidas || [];
                    cidadesAtendidas.forEach(cidade => {
                        const normalizedCidade = normalize(cidade);
                        
                        // Buscar munic√≠pio no GeoJSON
                        const municipioFeature = municipiosData.features.find(feature => {
                            const props = feature.properties;
                            const municipioName = props.name || props.nome || props.municipio || props.description;
                            return normalize(municipioName) === normalizedCidade;
                        });

                        if (municipioFeature) {
                            municipiosDestacados.push(municipioFeature);
                        }
                    });
                }

                if (municipiosDestacados.length === 0) {
                    console.log('Nenhum munic√≠pio encontrado no mapa para o representante:', representante.NomeRepresentante);
                    alert(`Nenhum munic√≠pio encontrado no mapa para ${representante.NomeRepresentante}`);
                    return;
                }

                console.log(`Encontrados ${municipiosDestacados.length} munic√≠pios para destacar`);

                // Criar camada de destaque
                const representanteColor = representativeColorMap.get(representante.id) || '#FF6B6B';
                
                highlightedMunicipiosLayer = L.geoJson(municipiosDestacados, {
                    style: {
                        fillColor: representanteColor,
                        weight: 3,
                        opacity: 1,
                        color: '#FFFFFF',
                        dashArray: '5,5',
                        fillOpacity: 0.8
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        const municipioName = props.name || props.nome || props.municipio || props.description;
                        
                        layer.bindTooltip(`
                            <strong>${municipioName}</strong><br>
                            <span style="color: ${representanteColor}; font-weight: bold;">‚óè</span> ${representante.NomeRepresentante}
                        `, {
                            permanent: false,
                            direction: 'top',
                            className: 'highlight-tooltip'
                        });
                    }
                }).addTo(map);

                // Fazer zoom para mostrar todos os munic√≠pios destacados
                if (highlightedMunicipiosLayer.getBounds().isValid()) {
                    map.fitBounds(highlightedMunicipiosLayer.getBounds(), { 
                        padding: [20, 20],
                        maxZoom: 8
                    });
                }

                // Destacar o card clicado
                document.querySelectorAll('.result-item').forEach((card, i) => {
                    if (i === index) {
                        card.style.backgroundColor = representanteColor + '20'; // 20% opacity
                        card.style.borderLeft = `4px solid ${representanteColor}`;
                    } else {
                        card.style.backgroundColor = '';
                        card.style.borderLeft = '';
                    }
                });

                // Atualizar t√≠tulo
                mainTitle.textContent = `√Åreas atendidas por ${representante.NomeRepresentante} (${municipiosDestacados.length} munic√≠pios)`;
            }

            function resetView(clearSearch = true) {
                // Reset de todas as sele√ß√µes
                if (selectedStateLayer) {
                    geoJsonLayer.resetStyle(selectedStateLayer);
                    selectedStateLayer = null;
                }

                if (selectedMunicipioLayer) {
                    selectedMunicipioLayer = null;
                }

                if (municipiosLayer) {
                    map.removeLayer(municipiosLayer);
                    municipiosLayer = null;
                }

                if (highlightedMunicipiosLayer) {
                    map.removeLayer(highlightedMunicipiosLayer);
                    highlightedMunicipiosLayer = null;
                }

                currentState = null;
                viewMode = 'states';

                map.setView([-15.78, -47.92], 4);
                if (clearSearch) searchInput.value = '';
                showInitialMessage();
                backButton.classList.add('hidden');
                mainTitle.textContent = 'Escolha sua regi√£o para encontrar representantes';
                
                // Atualizar estilos dos munic√≠pios se ainda estiverem vis√≠veis
                if (municipiosLayer) {
                    municipiosLayer.eachLayer(layer => {
                        const props = layer.feature.properties;
                        const municipioName = props.name || props.nome || props.municipio || props.description;
                        layer.setStyle(getMunicipioStyleByRepresentative(municipioName));
                    });
                }

                // Esconder legenda
                updateLegend([]);
                
                // Remove legenda de cores se existir
                const existingLegend = document.getElementById('color-legend');
                if (existingLegend) {
                    existingLegend.remove();
                }
                
                // Reset dos cards destacados
                document.querySelectorAll('.result-item').forEach(card => {
                    card.style.backgroundColor = '';
                    card.style.borderLeft = '';
                });
            }

            initializeApp();
        });
    </script>
</body>

</html>